# 05 | 动态代理：面向接口编程，屏蔽RPC处理流程

### 远程调用的魔法

**这里面用到的核心技术就是前面说的动态代理。**RPC 会自动给接口生成一个代理类，当我们在项目中注入接口的时候，运行过程中实际绑定的是这个接口生成的代理类。这样在接口方法被调用的时候，它实际上是被生成代理类拦截到了，这样我们就可以在生成的代理类里面，加入远程调用逻辑。

### 实现原理

利用动态代理给接口生成代理类.代理类中有和接口方法一样前面的方法,调用接口方法时会被转发到代理类

![image-20220109225341625](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220109225341625.png)

### 实现方法

单纯从代理功能上来看，JDK 默认的代理功能是有一定的局限性的，它要求被代理的类只能是接口。原因是因为生成的代理类会继承 Proxy 类，但 Java 是不支持多重继承的。

Javassist 的定位是能够操纵底层字节码,生成类复杂,但不需要反射,性能更好.

Byte Buddy 提供了更容易操作的 API，编写的代码可读性更高。更重要的是，生成的代理类执行速度比 Javassist 更快。



### 总结

具体技术框架，那就会涉及到选型

因为代理类是在运行中生成的，那么代理框架生成代理类的速度、生成代理类的字节码大小等等，都会影响到其性能——生成的字节码越小，运行所占资源就越小。

还有就是我们生成的代理类，是用于接口方法请求拦截的，所以每次调用接口方法的时候，都会执行生成的代理类，这时生成的代理类的执行效率就需要很高效。

最后一个是从我们的使用角度出发的，我们肯定希望选择一个使用起来很方便的代理类框架，比如我们可以考虑：API 设计是否好理解、社区活跃度、还有就是依赖复杂度等等。