# 23 | 如何在没有接口的情况下进行RPC调用？

### 应用场景有哪些？

例如一个轻量级网关需要调用各方服务API,但是不可能依赖所有的服务.

或者一个统一的测试平台,只有接口信息,需要调用服务测试.

### 怎么做？

RPC 框架要实现这个功能，我们可以使用泛化调用。

所谓的 RPC 调用，本质上就是调用端向服务端发送一条请求消息，服务端接收并处理，之后向调用端发送一条响应消息，调用端处理完响应消息之后，一次 RPC 调用就完成了。

基于此,我们只需要知道相关信息并封装请求后就能对服务端进行调用.

我们可以定义一个统一的接口（GenericService），调用端在创建 GenericService 代理时指定真正需要调用的接口的接口名以及分组名，而 GenericService 接口的 $invoke 方法的入参就是方法名以及参数信息。

```java
//伪代码
class GenericService {
  Object $invoke(String methodName, String[] paramTypes, Object[] params);
  //支持异步调用的泛化接口
  CompletableFuture<Object> $asyncInvoke(String methodName, String[] paramTypes, Object[] params);

}
```

这个通过统一的 GenericService 接口类生成的动态代理，来实现在没有接口的情况下进行 RPC 调用的功能，我们就称之为泛化调用。



问题:

调用端不能对入参对象进行正常的序列化，那调用端、服务端在接收到请求消息后，入参对象又该如何序列化与反序列化呢？

在 RPC 框架的整体架构中就包括了序列化插件，我们可以为泛化调用提供专属的序列化插件，通过这个插件，解决泛化调用中的序列化与反序列化问题。

调用端的入参对象（params）与返回值应该是什么类型呢？

可以使用 Map 类型的对象，之后通过泛化调用专属的序列化方式对这个 Map 对象进行序列化，服务端收到消息后，再通过泛化调用专属的序列化方式将其反序列成对象。