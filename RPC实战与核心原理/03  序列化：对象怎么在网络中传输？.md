# 03 | 序列化：对象怎么在网络中传输？

### 为什么需要序列化？

序列化就是将对象转换成二进制数据的过程，而反序列就是反过来将二进制转换为对象的过程。

因为网络传输的数据必须是二进制数据，所以在 RPC 调用中，对入参对象与返回值对象进行序列化与反序列化是一个必须的过程。

### 有哪些常用的序列化？

**实际上任何一种序列化框架，核心思想就是设计一种序列化协议**



 **JDK 原生序列化**:是由 ObjectOutputStream 完成的，而反序列化的具体实现是由 ObjectInputStream 完成的。

![image-20220107145154084](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220107145154084.png)

序列化过程就是在读取对象数据的时候，不断加入一些特殊分隔符，这些特殊分隔符用于在反序列化过程中截断用。

**JSON**:是典型的 Key-Value 方式的文本型序列化框架.

缺点: JSON 进行序列化的额外空间开销比较大;JSON 没有类型,需要反射解决,性能不好

**Hessian**:动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架

缺点:对Java一些常见对象不支持(Linked系列,Locale类,Byte/Short 反序列化的时候变成 Integer。)

**Protobuf  **:混合语言数据标准,轻便、高效的结构化数据存储格式，可以用于结构化数据序列化

优点:序列化后体积小;IDL 能清晰地描述语义;序列化速度快,不需要反射;向后兼容

### RPC 框架中如何选择序列化？

在序列化的选择上，与序列化协议的效率、性能、序列化协议后的体积相比，其通用性和兼容性的优先级会更高，因为他是会直接关系到服务调用的稳定性和可用率的，对于服务的性能来说，服务的可靠性显然更加重要。我们更加看重这种序列化协议在版本升级后的兼容性是否很好，是否支持更多的对象类型，是否是跨平台、跨语言的，是否有很多人已经用过并且踩过了很多的坑，其次我们才会去考虑性能、效率和空间开销。

![image-20220107150257427](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220107150257427.png)

其中 Hessian 在使用上更加方便，在对象的兼容性上更好；Protobuf 则更加高效，通用性上更有优势。

### RPC 框架在使用时要注意哪些问题？

**对象构造得过于复杂：**属性很多，并且存在多层的嵌套.序列化框架在序列化与反序列化对象时，对象越复杂就越浪费性能，消耗 CPU，这会严重影响 RPC 框架整体的性能；另外，对象越复杂，出现问题的概率就越高

**对象过于庞大：**浪费了性能、CPU，并且序列化一个如此大的对象是很耗费时间的，这肯定会直接影响到请求的耗时。

**使用序列化框架不支持的类作为入参类：**最好不要使用第三方集合类，尽量选用原生的、最为常用的集合类

**对象有复杂的继承关系：**对象关系越复杂，就越浪费性能，同时又很容易出现序列化上的问题。









