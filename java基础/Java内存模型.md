# Java内存模型

##  1. Java 内存模型引入

### 1.1 堆栈与线程关系模型

JVM内部使用的Java内存模型在线程栈和堆之间划分内存。 此图从逻辑角度说明了Java内存模型：

![java-memory-model-1](..\img\java-memory-model-1.png)

一般来说对象是被保存在堆上的,而线程上的局部变量分为两种,基本类型和引用类型.基本类型保存与线程栈上,两个线程间不可见.而引用类型是指向堆上的对象.

线程对堆上对象的访问模型可能如下图所示

![img](..\img\java-memory-model-3.png)

### 1.2 现代硬件内存结构

现代计算机硬件架构的简化图：

![img](../img/java-memory-model-4.png)

现代计算机中分成了多级缓存结构,最靠近CPU的是一组**CPU寄存器**,存储最快.之后是**CPU高速缓存存储器层**,一般有多层,速度介于寄存器和主存之间.之后是**主存**,存储性能相对最差,但是容量最大.各个CPU间通过主存共享内存数据.

### 1.3 JMM与硬件内存连接 - 引入

Java内存模型与硬件内存模型不同,对于硬件来说,无论是堆还是线程堆栈都存储与主存中,有时一部分的堆和堆栈会存储到寄存器和CPU高速缓存中.

如下图所示:

![img](../img/java-memory-model-5.png)

因为JMM与硬件内存模型存在的差异,会导致两个问题:

- Visibility of thread updates (writes) to shared variables. 共享变量的可见性
- Race conditions when reading, checking and writing shared variables. 读取,写入和检查共享变量时的竞态条件.

#### 1.3.1 共享变量的可见性

如果没有正确使用volatile关键字或同步,一个共享变量被修改后,其他线程对其不可及那

 volatile关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存.

#### 1.3.2 共享变量的竞态条件

如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能会出现竞态。

比如多条线程同时更新计数器字段,那么因为线程间不可见,导致更新的数值与参与修改的线程数量不一致.

要解决此问题，您可以使用Java synchronized块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为volatile.

## 2. JMM详解

###  2.1 基础

#### 2.1.1 并发模型分类

并发模型分为两种:共享内存和消息传递

共享内存(Java): 

- 线程通信:线程间共享程序的公共状态,通过写 - 读内存中的公共状态来隐式进行通信.
- 线程同步:显示同步,必须显示指定某个方法或某段代码需要在线程之间互斥执行

消息传递:

- 线程通信:线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信
- 线程同步:由于消息的发送必须在消息的接收之前，因此同步是隐式进行的

#### 2.1.2 Java内存模型抽象

堆内存对全部线程共享.局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。

Java线程通信由JMM控制,他决定了对共享变量的更改何时可见.

JMM定义了线程和主内存间的抽象关系:线程之间的共享变量存储在**主内存（main memory）**中，每个线程都有一个私有的**本地内存（local memory）**,本地内存中存储了该线程以读 / 写共享变量的副本.

**本地内存**时抽象概念,涵盖了缓存,写缓冲区,寄存器等,示意图如下:

![java-jmm-1](..\img\java-jmm-1.png)

#### 2.1.3 重排序

重排序分为三种:

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

- 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。(会导致内存可见性问题)

- 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。(会导致内存可见性问题)

在执行Java源码时可能会进过以下几种重排序:

![java-jmm-1](..\img\java-jmm-3.png)

在Java中可以通过添加volatile修饰禁止指令重排序.对后两种**处理器重排序**,JMM重排序规则,会在编译器生成指令序列时插入内存屏障指令,来禁止特定类型的处理器重排序.

#### 2.1.4 处理器重排序与内存屏障指令

处理器通过写缓存区缓存向内存写入的数据,同时通过批处理方式写入主存,并合并对同一个内存地址的多次操作.写缓冲区只对当前处理器可见,由于其特性,会导致读写顺序可能与实际的顺序不一致.

为了保证内存可见性，java 编译器在生成指令序列的**适当位置**会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：

| 屏障类型            | 指令示例                   | 说明                                                         |
| ------------------- | -------------------------- | ------------------------------------------------------------ |
| LoadLoad Barriers   | Load1; LoadLoad; Load2     | 确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。 |
| StoreStore Barriers | Store1; StoreStore; Store2 | 确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。 |
| LoadStore Barriers  | Load1; LoadStore; Store2   | 确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。 |
| StoreLoad Barriers  | Store1; StoreLoad; Load2   | 确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。 |

StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障.但是开销昂贵,当前处理器会把写缓存的数据全量刷新到主存.

####  2.1.5 happens-before

主要用来阐述操作之间的内存可见性。主要被使用到的规则如下:

- 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
- 监视器锁规则：对一个锁的解锁，happens- before 于随后对这个锁的加锁。

- volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。

- 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。

happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见,且前一个操作按顺序排在第二个操作之前.并不要求前一个操作一定早于后一个操作.

happens-before 与 JMM 的关系如下图所示:

![java-jmm-1](..\img\java-jmm-5.png)

### 2.2 重排序

#### 2.2.1 数据依赖性

如果有两个操作同时访问同一个数据,其中有一个对改数据进行了修改,操作间那么就产生了数据依赖.

| 名称   | 代码示例     | 说明                           |
| ------ | ------------ | ------------------------------ |
| 写后读 | a = 1;b = a; | 写一个变量之后，再读这个位置。 |
| 写后写 | a = 1;a = 2; | 写一个变量之后，再写这个变量。 |
| 读后写 | a = b;b = 1; | 读一个变量之后，再写这个变量。 |

上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。