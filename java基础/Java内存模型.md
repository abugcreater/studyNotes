# Java内存模型

##  1. Java 内存模型引入

### 1.1 堆栈与线程关系模型

JVM内部使用的Java内存模型在线程栈和堆之间划分内存。 此图从逻辑角度说明了Java内存模型：

![java-memory-model-1](..\img\java-memory-model-1.png)

一般来说对象是被保存在堆上的,而线程上的局部变量分为两种,基本类型和引用类型.基本类型保存与线程栈上,两个线程间不可见.而引用类型是指向堆上的对象.

线程对堆上对象的访问模型可能如下图所示

![img](..\img\java-memory-model-3.png)

### 1.2 现代硬件内存结构

现代计算机硬件架构的简化图：

![img](../img/java-memory-model-4.png)

现代计算机中分成了多级缓存结构,最靠近CPU的是一组**CPU寄存器**,存储最快.之后是**CPU高速缓存存储器层**,一般有多层,速度介于寄存器和主存之间.之后是**主存**,存储性能相对最差,但是容量最大.各个CPU间通过主存共享内存数据.

### 1.3 JMM与硬件内存连接 - 引入

Java内存模型与硬件内存模型不同,对于硬件来说,无论是堆还是线程堆栈都存储与主存中,有时一部分的堆和堆栈会存储到寄存器和CPU高速缓存中.

如下图所示:

![img](../img/java-memory-model-5.png)

因为JMM与硬件内存模型存在的差异,会导致两个问题:

- Visibility of thread updates (writes) to shared variables. 共享变量的可见性
- Race conditions when reading, checking and writing shared variables. 读取,写入和检查共享变量时的竞态条件.

#### 1.3.1 共享变量的可见性

如果没有正确使用volatile关键字或同步,一个共享变量被修改后,其他线程对其不可及那

 volatile关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存.

#### 1.3.2 共享变量的竞态条件

如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能会出现竞态。

比如多条线程同时更新计数器字段,那么因为线程间不可见,导致更新的数值与参与修改的线程数量不一致.

要解决此问题，您可以使用Java synchronized块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为volatile.

## 2. JMM详解

###  2.1 基础

#### 2.1.1 并发模型分类

并发模型分为两种:共享内存和消息传递

共享内存(Java): 

- 线程通信:线程间共享程序的公共状态,通过写 - 读内存中的公共状态来隐式进行通信.
- 线程同步:显示同步,必须显示指定某个方法或某段代码需要在线程之间互斥执行

消息传递:

- 线程通信:线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信
- 线程同步:由于消息的发送必须在消息的接收之前，因此同步是隐式进行的

#### 2.1.2 Java内存模型抽象

堆内存对全部线程共享.局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。

Java线程通信由JMM控制,他决定了对共享变量的更改何时可见.

JMM定义了线程和主内存间的抽象关系:线程之间的共享变量存储在**主内存（main memory）**中，每个线程都有一个私有的**本地内存（local memory）**,本地内存中存储了该线程以读 / 写共享变量的副本.

**本地内存**时抽象概念,涵盖了缓存,写缓冲区,寄存器等,示意图如下:

![java-jmm-1](..\img\java-jmm-1.png)

#### 2.1.3 重排序

重排序分为三种:

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

- 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。(会导致内存可见性问题)

- 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。(会导致内存可见性问题)

在执行Java源码时可能会进过以下几种重排序:

![java-jmm-1](..\img\java-jmm-3.png)

在Java中可以通过添加volatile修饰禁止指令重排序.对后两种**处理器重排序**,JMM重排序规则,会在编译器生成指令序列时插入内存屏障指令,来禁止特定类型的处理器重排序.

#### 2.1.4 处理器重排序与内存屏障指令

处理器通过写缓存区缓存向内存写入的数据,同时通过批处理方式写入主存,并合并对同一个内存地址的多次操作.写缓冲区只对当前处理器可见,由于其特性,会导致读写顺序可能与实际的顺序不一致.

为了保证内存可见性，java 编译器在生成指令序列的**适当位置**会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：

| 屏障类型            | 指令示例                   | 说明                                                         |
| ------------------- | -------------------------- | ------------------------------------------------------------ |
| LoadLoad Barriers   | Load1; LoadLoad; Load2     | 确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。 |
| StoreStore Barriers | Store1; StoreStore; Store2 | 确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。 |
| LoadStore Barriers  | Load1; LoadStore; Store2   | 确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。 |
| StoreLoad Barriers  | Store1; StoreLoad; Load2   | 确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。 |

StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障.但是开销昂贵,当前处理器会把写缓存的数据全量刷新到主存.

####  2.1.5 happens-before

主要用来阐述操作之间的内存可见性。主要被使用到的规则如下:

- 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
- 监视器锁规则：对一个锁的解锁，happens- before 于随后对这个锁的加锁。

- volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。

- 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。

happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见,且前一个操作按顺序排在第二个操作之前.并不要求前一个操作一定早于后一个操作.

happens-before 与 JMM 的关系如下图所示:

![java-jmm-1](..\img\java-jmm-5.png)

### 2.2 重排序

#### 2.2.1 数据依赖性

如果有两个操作同时访问同一个数据,其中有一个对改数据进行了修改,操作间那么就产生了数据依赖.

| 名称   | 代码示例     | 说明                           |
| ------ | ------------ | ------------------------------ |
| 写后读 | a = 1;b = a; | 写一个变量之后，再读这个位置。 |
| 写后写 | a = 1;a = 2; | 写一个变量之后，再写这个变量。 |
| 读后写 | a = b;b = 1; | 读一个变量之后，再写这个变量。 |

上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。

编译器和处理器在重排序(仅针对单个处理器)时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

#### 2.2.2 as-if-serial 语义

as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。

所以编译器和处理器不会对有数据以来的操作进行重排序.

#### 2.2.3 程序顺序规则

当一个程序中存在以下三处happens 操作:

- A happens- before B；
- B happens- before C；
- A happens- before C；

这里 A happens- before B，但实际执行时 B 却可以排在 A 之前执行,因为A和B之间并没有数据依赖.

在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标.

#### 2.2.4  重排序对多线程的影响

当存在如下操作时:

```java
	//writer操作会对reader操作产生影响,但writer和reader方法并没有数据依赖,所以会发生指令重排序
 	public void writer() {
        a = 1;                   //1
        flag = true;             //2
    }

    public void reader() {
        if (flag) {                //3
            int i =  a * a;        //4
            ……
   }
```

操作 3 和操作 4 重排序后，程序的执行时序图：

![java-jmm-1](..\img\java-jmm-9.png)

当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。

图上的temp存放在名为重排序缓冲(reorder buffer ROB)的硬件缓冲中.

猜测执行实质上对操作 3 和 4 做了重排序。重排序在这里破坏了多线程程序的语义!

### 2.3 顺序一致性

#### 2.3.1 数据竞争与顺序一致性保证

JMM中对数据竞争的定义:

- 在一个线程中写一个变量，
- 在另一个线程读同一个变量，
- 而且写和读没有通过同步来排序。

如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序

JMM中内存一致性保证:如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）-- 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同

#### 2.3.2 顺序一致性内存模型

顺序一致性内存模型,提供了极强的内存可见性保证,他具有两大特点:

- 一个线程中的所有操作必须按照程序的顺序来执行,所有线程都只能看到一个单一的操作执行顺序
- 每个操作都必须原子执行且立刻对所有线程可见

![java-jmm-1](..\img\java-jmm-10.png)

该模型有单一的全局内存,内存通过左右摆动开关,执行任意一个线程,每个线程必须顺序进行读/写操作.该开关装置将所有线程中的所有读/写操作都串行化了.

当多线程无同步执行时:

![java-jmm-1](..\img\java-jmm-12.png)

在顺序一致性模型中虽然整体执行是无序的,但所有线程只能看到一个顺序,且每个操作必须立即对任意线程可见.

#### 2.3.3 同步程序的顺序一致性效果

```java
	// 当对writer/reader 方法加锁后,就是一个正确同步的多线程程序
	public synchronized void writer() {
        a = 1;
        flag = true;
    }
    public synchronized void reader() {
        if (flag) {
            int i = a;
            ……
        }
    }
```

根据 JMM 规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。

![java-jmm-1](..\img\java-jmm-13.png)

从这里我们可以看到 JMM 在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。

#### 2.3.4 未同步程序的执行特性

对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：线程读取的可能是过期的或者初始值,但不会无中生有.为此,JVM在堆上分配对象时,会先清零内存空间,然后才在上面分配对象.

未同步的执行特性在顺序一致性模型和JMM中的执行差异:

- 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。

- 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。

- JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性。

第三点与处理器总线工作机制有关,数据在处理器和内存中的传递通过**总线事务**完成,总线事务包括读事务和写事务.数据流动方向分别为内存到处理器,处理器到内存.总线会识图使用并发总线事务.而一个处理器在执行总线事务时,总线会禁止其他处理器读写内存.

Java会把64的变量分成两个32位的进行,这会导致两个变量在两个总线事务中执行.那么此时对这个64的变量的读写将不具有原子性.

## 3. 总结

### 3.1  处理器内存模型

顺序一致性内存模型是一个理论参考模型，JMM 和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照,但是考虑到性能问题,没有严格按照顺序一致性。

常见的内存模型,**在不发生数据依赖的情况下**:

- TSO(total store ordering):放松程序中写 - 读操作的顺序
- PSO(partial store order):在TSO基础上继续放松 写 - 写顺序
- RMO(relaxed memory order)和PowerPC :在1,2基础上继续放松程序中读 - 写和读 - 读操作的顺序

因为常见的处理器内存模型要比JMM弱,所以需要在编译时在适当位置插入内存屏障保证重排序.

![java-jmm-1](..\img\java-jmm-x01.png)

JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 java 程序员呈现了一个一致的内存模型

### 3.2 JMM，处理器内存模型与顺序一致性内存模型之间的关系

JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：

![java-jmm-1](..\img\java-jmm-x02.png)

越是追求执行性能的语言，内存模型设计的会越弱。

### 3.3 JMM 的设计

JMMd 设计:一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松

JMM 把 happens- before 要求禁止的重排序分为了下面两类：

- 会改变程序执行结果的重排序,JMM 要求编译器和处理器必须禁止这种重排序。
- 不会改变程序执行结果的重排序,JMM 对编译器和处理器不作要求。

JMM设计示意图如下:

![java-jmm-1](..\img\java-jmm-x03.png)

### 3.3 JMM 的内存可见性保证

Java 程序的内存可见性保证按程序类型可以分为下列三类：

- **单线程程序**。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。
- **正确同步的多线程程序**。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
- **未同步 / 未正确同步的多线程程序**。JMM 为它们提供了最小安全性保障

 JMM 中与在顺序一致性内存模型中的执行结果的异同：

![java-jmm-x04](..\img\java-jmm-x04.png)