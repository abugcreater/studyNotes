# 11. 基于角色的权限控制：RBAC

**在 Kubernetes 项目中，负责完成授权（Authorization）工作的机制，就是 RBAC**：基于角色的访问控制（Role-Based Access Control）

对于**RBAC**需要明确三个基本概念:

1. Role：角色，它其实是一组规则，定义了一组对 Kubernetes API 对象的操作权限。
2. Subject：被作用者，既可以是“人”，也可以是“机器”，也可以使你在 Kubernetes 里定义的“用户”。
3. RoleBinding：定义了“被作用者”和“角色”的绑定关系。



Role是一个API对象,定义如下:

```yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: mynamespace #作用域mynamespace, 具体空间example-role
  name: example-role
rules:   # 定义规则,允许被作用者
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

> Namespace 是 Kubernetes 项目里的一个逻辑管理单位,仅限于逻辑隔离,默认为default.

RoleBinding 本身也是一个 Kubernetes 的 API 对象

```yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: example-rolebinding
  namespace: mynamespace
subjects: #被作用者,这里是名为example-user 的user对象
- kind: User
  name: example-user
  apiGroup: rbac.authorization.k8s.io
roleRef: # 角色引用,即规则引用
  kind: Role
  name: example-role
  apiGroup: rbac.authorization.k8s.io
```

> Kubernetes 里的“User”，也就是“用户”，只是一个授权系统里的逻辑概念。可以通过外部认证服务，比如 Keystone提供;或者直接在 APIServer 指定一个用户名、密码文件

利用roleRef字段,RoleBinding 对象就可以直接通过名字，来引用我们前面定义的 Role 对象（example-role），从而定义了“被作用者（Subject）”和“角色（Role）”之间的绑定关系

Role 和 RoleBinding 对象都是 Namespaced 对象,他们的规则只对指定的Namespaced 内有效,roleRef 也只能引用当前Namespaced 的对象.

**对于非 Namespaced（Non-namespaced）对象,我们就必须要使用 ClusterRole 和 ClusterRoleBinding 这两个组合了**

这两者除了没有namespace字段,与 Role 和 RoleBinding 完全一样

Role 对象的 rules 字段也可以进一步细化。比如，你可以只针对某一个具体的对象进行权限设置，如下所示：

```yaml
rules:
- apiGroups: [""]
  resources: ["configmaps"] #指定使用对象为configmaps
  resourceNames: ["my-config"]
  verbs: ["get"]
```

----

 **Kubernetes 负责管理的“内置用户”ServiceAccount的分配权限过程**

**首先，我们要定义一个 ServiceAccount**。

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  namespace: mynamespace
  name: example-sa
```

只需要 Name 和 Namespace 这两个最基本的字段

**然后，我们通过编写 RoleBinding 的 YAML 文件，来为这个 ServiceAccount 分配权限：**

```yaml
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: example-rolebinding
  namespace: mynamespace
subjects:
- kind: ServiceAccount
  name: example-sa
  namespace: mynamespace
roleRef:
  kind: Role
  name: example-role
  apiGroup: rbac.authorization.k8s.io
```

**接着，我们用 kubectl 命令创建这三个对象：**

```sh
$ kubectl create -f svc-account.yaml
$ kubectl create -f role-binding.yaml
$ kubectl create -f role.yaml
```

查看ServiceAccount 详细信息

```sh
$ kubectl get sa -n mynamespace -o yaml
- apiVersion: v1
  kind: ServiceAccount
  metadata:
    creationTimestamp: 2018-09-08T12:59:17Z
    name: example-sa
    namespace: mynamespace
    resourceVersion: "409327"
    ...
  secrets:
  - name: example-sa-token-vmfg6
```

Kubernetes 会为一个 ServiceAccount 自动创建并分配一个 Secret 对象，即：上述 ServiceAcount 定义里最下面的 secrets 字段,一般称为token.文件的内容一般是证书或者密码，它以一个 Secret 对象的方式保存在 Etcd 当中。

这时候，用户的 Pod，就可以声明使用这个 ServiceAccount 了，比如下面这个例子：

```yaml
apiVersion: v1
kind: Pod
metadata:
  namespace: mynamespace
  name: sa-token-test
spec:
  containers:
  - name: nginx
    image: nginx:1.7.9
  serviceAccountName: example-sa # ServiceAccount 名称未example-sa,如果没有声明就直接是default
```

 Pod 运行起来之后，我们就可以看到，该 ServiceAccount 的 token，也就是一个 Secret 对象，被 Kubernetes 自动挂载到了容器的 /var/run/secrets/kubernetes.io/serviceaccount 目录下

---

一个 ServiceAccount，在 Kubernetes 里对应的“用户”的名字是

```yaml
system:serviceaccount:<ServiceAccount 名字 >
```

而它对应的内置“用户组”的名字，就是：

```yaml
system:serviceaccounts:<Namespace 名字 >
```

RoleBinding 里定义如下的 subjects：

```yaml
subjects:
- kind: Group
  name: system:serviceaccounts:mynamespace
  apiGroup: rbac.authorization.k8s.io
```

这就意味着这个 Role 的权限规则，作用于 mynamespace 里的所有 ServiceAccount。如果不指定mynamespace那么将作用与所有的ServiceAccount.

**在 Kubernetes 中已经内置了很多个为系统保留的 ClusterRole，它们的名字都以 system: 开头**。可以通过 kubectl get clusterroles 查看到它们



**Kubernetes 还提供了四个预先定义好的 ClusterRole 来供用户直接使用：**

1. cluster-admin；
2. admin；
3. edit；
4. view。



































