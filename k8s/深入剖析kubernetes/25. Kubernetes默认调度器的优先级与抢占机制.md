# 25. Kubernetes默认调度器的优先级与抢占机制

高优先级的Pod调度失败会挤走低优先级的Pod,确保高优先级的调度成功.如果想要使用这个机制,就需要先提交一个PriorityClass 的定义:

```yaml
apiVersion: scheduling.k8s.io/v1beta1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false # 是否设置为系统默认值
description: "This priority class should be used for high priority service pods only."
```

该对象的优先级是1000000（一百万）.

**Kubernetes 规定，优先级是一个 32 bit 的整数，最大值不超过 1000000000（10 亿，1 billion），并且值越大代表优先级越高。**高于这个数的是被K8S保留的,分配给系统Pod,确保系统Pod不会被抢占.

当我们声明使用PriorityClass时就拥有了对应的优先级,其他没有生命的优先级为0.

声明的配置文件如下:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    env: test
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
  priorityClassName: high-priority
```

---

**优先级的概念体现在高优先级的 Pod 就可能会比低优先级的 Pod 提前出队**

**抢占体现在高优先级Pod调度失败,调度器在集群中寻找节点,删除节点上一个或多个低优先级Pod的过程**

调度器会将抢占者的 spec.nominatedNodeName 字段，设置为被抢占的 Node 的名字.然后进入下一个调度周期.在下一个周期决定是否要抢占.因为被抢占者删除需要优雅退出的时间.

-----

**抢占机制又是如何设计的**

> 背景



Kubernetes 有两个调度队列.

**第一个队列，叫作 activeQ。**队列中放的都是下一个调度周期需要调度的对象

**第二个队列，叫作 unschedulableQ**，专门用来存放调度失败的 Pod。

unschedulableQ中Pod被更新后,调度器会自动把Pod移动到activeQ中.

> 实际实现

调度失败时间会触发**调度器为抢占者寻找牺牲者的流程**

1. 调度器检查失败原因,确认是否存在能被抢占的节点
2. 如果有节点存在,调度器会把自己缓存的所有节点信息复制一份，然后使用这个副本来模拟抢占过程
   - 遍历所有符合条件的节点,逐一删除低优先级Pod,知道满足条件
   - 寻找最佳结果,**尽量减少抢占对整个系统的影响**

当上一步找到最佳结果时就可以真正抢占了

- **第一步**，调度器会检查牺牲者列表，清理这些 Pod 所携带的 nominatedNodeName 字段。
- **第二步**，调度器会把抢占者的 nominatedNodeName，设置为被抢占的 Node 的名字。
- **第三步**，调度器会开启一个 Goroutine，同步地删除牺牲者。

**接下来，调度器就会通过正常的调度流程把抢占者调度成功**。

---

对于任意一个待调度 Pod 来说，因为有上述抢占者的存在，它的调度过程，其实是有一些特殊情况需要特殊处理的。

如果调度队列的Pod中存在nominatedNodeName 字段是node的名字.**调度器就会对这个 Node ，将同样的 Predicates 算法运行两遍。**

**第一遍**， 调度器会假设上述“潜在的抢占者”已经运行在这个节点上，然后执行 Predicates 算法；

**第二遍**， 调度器会正常执行 Predicates 算法，即：不考虑任何“潜在的抢占者”。



















































































