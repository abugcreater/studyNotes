# 4. 控制器模型

以deployment为例,查看他的yaml配置文件:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # 期望值
  template:  #podtemplate 代表被管理的pod类型
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
```

类似deployment控制器都是 kube-controller-manager组件中的.们可以查看一下 Kubernetes 项目的 pkg/controller 目录：

```sh
$ cd kubernetes/pkg/controller/
$ ls -d */              
deployment/             job/                    podautoscaler/          
cloud/                  disruption/             namespace/              
replicaset/             serviceaccount/         volume/
cronjob/                garbagecollector/       nodelifecycle/          replication/            statefulset/            daemon/
...
```

它们都遵循 Kubernetes 项目中的一个通用编排模式，即：**控制循环（control loop）**.即跟进期望状态和实际状态动态调整.

**在具体实现中，实际状态往往来自于 Kubernetes 集群本身**。**而期望状态，一般来自于用户提交的 YAML 文件**。

以 Deployment 为例，简单描述一下它对控制器模型的实现：

1. Deployment 控制器从 Etcd 中获取到所有携带了“app: nginx”标签的 Pod，然后统计它们的数量，这就是实际状态；
2. Deployment 对象的 Replicas 字段的值就是期望状态；
3. Deployment 控制器将两个状态做比较，然后根据比较结果，确定是创建 Pod，还是删除已有的 Pod(**执行k8s主要编排逻辑 -- 通常被叫作调谐（Reconcile）**)

而调谐的最终结果，往往都是对被控制对象的某种写操作。**这也是 Kubernetes 项目“面向 API 对象编程”的一个直观体现。**



大多数控制器，都会使用 PodTemplate 来统一定义它所要管理的 Pod。更有意思的是，我们还会看到其他类型的对象模板，比如 Volume 的模板。对 Deployment 以及其他类似的控制器，做一个简单总结了：

![控制器配置定义](../../img/k8s-16-1.png)

上图所示，**类似 Deployment 这样的一个控制器，实际上都是由上半部分的控制器定义（包括期望状态），加上下半部分的被控制对象的模板组成的。**

这就是为什么，在所有 API 对象的 Metadata 里，都有一个字段叫作 ownerReference，用于保存当前这个 API 对象的拥有者（Owner）的信息。





















