# 5. 作业副本与水平扩展

Deployment实现了 Pod 的“水平扩展 / 收缩”（horizontal scaling out/in）.而这个能力的实现，依赖的是 Kubernetes 项目中的一个非常重要的概念（API 对象）：ReplicaSet。

ReplicaSet的结构如下:

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:   # 元数据
  name: nginx-set
  labels:
    app: nginx
spec:
  replicas: 3 #副本数量
  selector:  #选择器
    matchLabels:
      app: nginx
  template: # 模版
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
```

**一个 ReplicaSet 对象，其实就是由副本数目的定义和一个 Pod 模板组成的而Deployment 控制器实际操纵的，正是这样的 ReplicaSet 对象**

Deployment，与 ReplicaSet，以及 Pod 的关系简单来说是:通过层层控制通知pod个数

![k8s-5-1.png](../../img/k8s-5-1.png)

容器能保证自己始终是 Running 状态的前提下，ReplicaSet 调整 Pod 的个数才有意义。

---

用户可以通过 ` kubectl scale`指令滚动更新

```sh
$ kubectl scale deployment nginx-deployment --replicas=4
deployment.apps/nginx-deployment scaled
```

 `kubectl rollout status` 可以实时查看 Deployment 对象的状态变化

```sh
$ kubectl rollout status deployment/nginx-deployment
Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
deployment.apps/nginx-deployment successfully rolled out

输出表示已经有2个Pod进入 UP-TO-DATE 状态
```

我们修改 Deployment 的 Pod 模板，“滚动更新”就会被自动触发。

有多种方法修改Deployment ,如edit指令编辑API对象:

```sh
$ kubectl edit deployment/nginx-deployment
... 
    spec:
      containers:
      - name: nginx
        image: nginx:1.9.1 # 1.7.9 -> 1.9.1
        ports:
        - containerPort: 80
...
deployment.extensions/nginx-deployment edited
```

>  该指令是实现是把 API 对象的内容下载到了本地文件，让你修改完成后再提交上去。

修改完成后提交触发滚动更新.

**将一个集群中正在运行的多个 Pod 版本，交替地逐一升级的过程，就是“滚动更新”。**

为了进一步保证服务的连续性，Deployment Controller 还会确保，在任何时间窗口内，只有指定比例的 Pod 处于离线状态。同时，它也会确保，在任何时间窗口内，只有指定比例的新 Pod 被创建出来。这两个比例的值都是可以配置的，默认都是 DESIRED 值的 25%。

以上描述的称为`RollingUpdateStrategy`,即滚动更新策略.

```yaml
spec:
...
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
```

在上面这个 RollingUpdateStrategy 的配置中，maxSurge 指定的是除了 DESIRED 数量之外，在一次“滚动”中，Deployment 控制器还可以创建多少个新 Pod；而 maxUnavailable 指的是，在一次“滚动”中，Deployment 控制器可以删除多少个旧 Pod。

Deployment 的每次滚动更新都会创建一个新的`ReplicaSet`,拓展成关系图如下:

![k8s-5-2.png](../../img/k8s-5-2.png)

-----

**kubectl set image**的指令可以修改pod对应的镜像

```sh
$ kubectl set image deployment/nginx-deployment nginx=nginx:1.91
deployment.extensions/nginx-deployment image updated
```

 **kubectl rollout undo** 命令，就能把整个 Deployment 回滚到上一个版本：

```sh
$ kubectl rollout undo deployment/nginx-deployment
deployment.extensions/nginx-deployment
```

 **kubectl rollout history**命令查看对应的变更版本.

```sh
$ kubectl rollout history deployment/nginx-deployment
deployments "nginx-deployment"
REVISION    CHANGE-CAUSE
1           kubectl create -f nginx-deployment.yaml --record
2           kubectl edit deployment/nginx-deployment
3           kubectl set image deployment/nginx-deployment nginx=nginx:1.91
```

**我们就可以在 kubectl rollout undo 命令行最后，加上要回滚到的指定版本的版本号，就可以回滚到指定版本了**。

```sh
$ kubectl rollout undo deployment/nginx-deployment --to-revision=2
deployment.extensions/nginx-deployment
```

因为每次滚动更新都会生产新的ReplicaSet ,如果要控制ReplicaSet 的数量.可以先对deployment暂停滚动更新,然后在恢复,那么中间修改的记录只会生产一条ReplicaSet .

```sh
$ kubectl rollout pause deployment/nginx-deployment
deployment.extensions/nginx-deployment paused

$ kubectl rollout resume deploy/nginx-deployment
deployment.extensions/nginx-deployment resumed
```









**Deployment 对应用进行版本控制的具体原理**

Deployment 实际上是一个**两层控制器**。首先，它通过**ReplicaSet 的个数**来描述应用的版本；然后，它再通过**ReplicaSet 的属性**（比如 replicas 的值），来保证 Pod 的副本数量。

















