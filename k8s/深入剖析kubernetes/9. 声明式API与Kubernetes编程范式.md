# 9. 声明式API与Kubernetes编程范式

Kubernetes 中通过`apply -f`创建并更新对象,才是**声明式 API**.

相对于replace来说:kubectl replace 的执行过程，是使用新的 YAML 文件中的 API 对象，**替换原有的 API 对象**；而 kubectl apply，则是执行了一个**对原有 API 对象的 PATCH 操作**。

声明式API,**一次能处理多个写操作，并且具备 Merge 能力**。

----

**已Istio 项目为例**

Istio 是基于K8S的微服务治理架构,他的架构如下:

![k8s-9-1.jpg](../../img/k8s-9-1.jpg)

在上面这个架构图中，我们不难看到 Istio 项目架构的核心所在。**Istio 最根本的组件，是运行在每一个应用 Pod 里的 Envoy 容器**。

> **Envoy** 以sidecar容器运行的高性能网络代理,运行在被治理的Pod中

Pilot 组件,能够调用**Envoy** 的API,进行服务治理.

**Istio 项目使用的，是 Kubernetes 中的一个非常重要的功能，叫作 Dynamic Admission Control。**

 Kubernetes 项目里一组被称为 Admission Controller 的代码，可以选择性地被编译进 APIServer 中，在 API 对象创建之后会被立刻调用到。而"初始化"的操作借助的就是Admission 功能.但该功能存在缺点:需要重新编译并重启APIServer.

`Dynamic Admission Control`就是热拔插的Admission 机制.

---

**Istio 为Pod自动注入Envoy容器的Initializer**

示例:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', 'echo Hello Kubernetes! && sleep 3600']
  - name: envoy  #自动加上 Envoy 容器的配置
    image: lyft/envoy:845747b88f102c0fd262ab234308e9e22f693a1
    command: ["/usr/local/bin/envoy"]
    ...
```

**实现步骤**





**首先，Istio 会将这个 Envoy 容器本身的定义，以 ConfigMap 的方式保存在 Kubernetes 当中**。这个 ConfigMap（名叫：envoy-initializer）的定义如下所示：

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: envoy-initializer
data:  # Pod对象的一部分定义
  config: | 
    containers:
      - name: envoy
        image: lyft/envoy:845747db88f102c0fd262ab234308e9e22f693a1
        command: ["/usr/local/bin/envoy"]
        args:
          - "--concurrency 4"
          - "--config-path /etc/envoy/envoy.json"
          - "--mode serve"
        ports:
          - containerPort: 80
            protocol: TCP
        resources:
          limits:
            cpu: "1000m"
            memory: "512Mi"
          requests:
            cpu: "100m"
            memory: "64Mi"
        volumeMounts:
          - name: envoy-conf
            mountPath: /etc/envoy
    volumes:
      - name: envoy-conf
        configMap:
          name: envoy
```

Initializer 要做的工作，就是把这部分 Envoy 相关的字段，自动添加到用户提交的 Pod 的 API 对象里。这就涉及到了更新用户Pod对象,必须使用 PATCH API 来完成。而这种 PATCH API，正是声明式 API 最主要的能力。



**接下来，Istio 将一个编写好的 Initializer，作为一个 Pod 部署在 Kubernetes 中**。这个 Pod 的定义非常简单，如下所示：

```yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: envoy-initializer
  name: envoy-initializer
spec:
  containers:
    - name: envoy-initializer
      image: envoy-initializer:0.0.1
      imagePullPolicy: Always
```

这个initializer就是事先写好的控制器,会不断获取实际状态,以达到期望状态.

Initializer 控制器的工作逻辑里，它首先会从 APIServer 中拿到这个 ConfigMap：

```go
func doSomething(pod) {
  cm := client.Get(ConfigMap, "envoy-initializer")
}
```

然后，把这个 ConfigMap 里存储的 containers 和 volumes 字段，直接添加进一个空的 Pod 对象里.

最后使用Kubernetes 的 API 库,直接使用新旧两个 Pod 对象，生成一个 TwoWayMergePatch.

**有了这个 TwoWayMergePatch 之后，Initializer 的代码就可以使用这个 patch 的数据，调用 Kubernetes 的 Client，发起一个 PATCH 请求**。

**Istio 项目的核心，就是由无数个运行在应用 Pod 中的 Envoy 容器组成的服务代理网格**。这也正是 Service Mesh 的含义。

----

而这个机制得以实现的原理，正是借助了 Kubernetes 能够对 API 对象进行在线更新的能力，这也正是**Kubernetes“声明式 API”的独特之处：**

- 首先，所谓“声明式”，指的就是我只需要提交一个定义好的 API 对象来“声明”，我所期望的状态是什么样子。
- 其次，“声明式 API”允许有多个 API 写端，以 PATCH 的方式对 API 对象进行修改，而无需关心本地原始 YAML 文件的内容。
- 最后，也是最重要的，有了上述两个能力，Kubernetes 项目才可以基于对 API 对象的增、删、改、查，在完全无需外界干预的情况下，完成对“实际状态”和“期望状态”的调谐（Reconcile）过程。

**声明式 API，才是 Kubernetes 项目编排能力“赖以生存”的核心所在**



**PS: kubectl apply 是通过mvcc 实现的并发写**







































