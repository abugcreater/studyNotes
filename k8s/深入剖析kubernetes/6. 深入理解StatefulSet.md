# 6. 深入理解StatefulSet

> 实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，就被称为“有状态应用”（Stateful Application）

得益于“控制器模式”的设计思想，Kubernetes 项目很早就在 Deployment 的基础上，扩展出了对“有状态应用”的初步支持。这个编排功能，就是：StatefulSet。

StatefulSet 把真实世界里的应用状态，抽象为了两种情况：

1. **拓扑状态**。这种情况意味着，应用的多个实例之间不是完全对等的关系。这些应用实例，必须按照某些顺序启动
2. **存储状态**。这种情况意味着，应用的多个实例分别绑定了不同的存储数据。



**StatefulSet 的核心功能，就是通过某种方式记录这些状态，然后在 Pod 被重新创建时，能够为新 Pod 恢复这些状态。**

--------

## 处理网络状态

以`Headless Service`概念为例讲解`StatefulSet `,`Headless Service`与`service`的区别在于API对象中的`spec.clusterIP:None`这也就是 Headless 的含义。所以，这个 Service 被创建后并不会被分配一个 VIP，而是会以 DNS 记录的方式暴露出它所代理的 Pod。

**，Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址。**

**service的访问方式**

**第一种方式，是以 Service 的 VIP（Virtual IP，即：虚拟 IP）方式**。访问service的IP是吧请求转到代理的Pod上

**第二种方式，就是以 Service 的 DNS 方式**。

- Normal Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，正是 my-svc 这个 Service 的 VIP，后面的流程就跟 VIP 方式一致了
-  Headless Service。这种情况下，你访问“my-svc.my-namespace.svc.cluster.local”解析到的，直接就是 my-svc 代理的某一个 Pod 的 IP 地址。



 Headless Service 所代理的所有 Pod 的 IP 地址，都会被绑定一个这样格式的 DNS 记录,格式如下所示:

```
<pod-name>.<svc-name>.<namespace>.svc.cluster.local
```

---

**StatefulSet 又是如何使用这个 DNS 记录来维持 Pod 的拓扑状态的呢？**

 StatefulSet 的 YAML 文件和Deployment 的唯一区别，就是多了一个 `serviceName=nginx` 字段。

这个字段的作用，就是告诉 StatefulSet 控制器，在执行控制循环（Control Loop）的时候，请使用 nginx 这个 Headless Service 来保证 Pod 的“可解析身份”

创建完这两个对象后,利用 -w(watch功能) 时查看 StatefulSet 创建两个有状态实例的过程：

```sh
$ kubectl get pods -w -l app=nginx
NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         19s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         20s
```

StatefulSet 给它所管理的所有 Pod 的名字，进行了编号，编号规则是：-.这些编号从0开始累加.

而Pod的创建也是严格按照顺序进行.

通过这种严格的对应规则，**StatefulSet 就保证了 Pod 网络标识的稳定性**。

通过这种方法，**Kubernetes 就成功地将 Pod 的拓扑状态（比如：哪个节点先启动，哪个节点后启动），按照 Pod 的“名字 + 编号”的方式固定了下来**。

----

## 处理存储状态

 StatefulSet 对存储状态的管理机制 基于`Persistent Volume Claim`功能.`Persistent Volume Claim`是对volume的声明,描述了名称,存储模式和存储大小.

如果我们不使用声明直接引用定义

1. 会增加使用成本,开发者需要了解Volume 的管理和远程持久化存储的知识
2. 会导致对应的存储服务器的地址、用户名、授权文件的位置被暴露

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: rbd
spec:
  containers:
    - image: kubernetes/pause
      name: rbd-rw
      volumeMounts:
      - name: rbdpd
        mountPath: /mnt/rbd
  volumes:
    - name: rbdpd
      rbd:     #Ceph RBD 的配置信息被泄漏
        monitors:
        - '10.16.154.78:6789'
        - '10.16.154.82:6789'
        - '10.16.154.83:6789'
        pool: kube
        image: foo
        fsType: ext4
        readOnly: true
        user: admin
        keyring: /etc/ceph/keyring
        imageformat: "2"
        imagefeatures: "layering"
```

为了解决这个问题,**Kubernetes 项目引入了一组叫作 Persistent Volume Claim（PVC）和 Persistent Volume（PV）的 API 对象，大大降低了用户声明和使用持久化 Volume 的门槛。**

第一步**：定义一个 PVC，声明想要的 Volume 的属性：**

```yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: pv-claim
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

这个定义不需要任何关于 Volume 细节的字段，只有描述性的属性和定义。

第二步**：在应用的 Pod 中，声明使用这个 PVC：**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pv-pod
spec:
  containers:
    - name: pv-container
      image: nginx
      ports:
        - containerPort: 80
          name: "http-server"
      volumeMounts:
        - mountPath: "/usr/share/nginx/html"
          name: pv-storage
  volumes:
    - name: pv-storage
      persistentVolumeClaim:
        claimName: pv-claim
```

K8S会从定义的PV（Persistent Volume）对象中选取一个合适的自动绑定.

**PV对象配置**

```yaml
kind: PersistentVolume
apiVersion: v1
metadata:
  name: pv-volume
  labels:
    type: local
spec:
  capacity:
    storage: 10Gi
  rbd:
    monitors:
    - '10.16.154.78:6789'
    - '10.16.154.82:6789'
    - '10.16.154.83:6789'
    pool: kube
    image: foo
    fsType: ext4
    readOnly: true
    user: admin
    keyring: /etc/ceph/keyring
    imageformat: "2"
    imagefeatures: "layering"
```

 PVC 和 PV 的设计，**实际上类似于“接口”和“实现”的思想**。

-----

**在StatefulSet中的使用**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  serviceName: "nginx"
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.9.1
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 1Gi
```

我们为这个 StatefulSet 额外添加了一个 volumeClaimTemplates 字段,由这个StatefulSet 创建的Pod会自动创建PVC对象并与PV绑定.PVC的名称都以“<PVC 名字 >-<StatefulSet 名字 >-< 编号 >”的方式命名.

```sh
$ kubectl get pvc -l app=nginx
NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s
```

当我们删除创建的Pod后,新创建的Pod会自动和原有的PVC绑定.

因为,Pod被删除后PVC和PV并不会被删除,而数据也会被存储在远端服务器上.

此时，StatefulSet 控制器发现，一个名叫 web-0 的 Pod 消失了。所以，控制器就会重新创建一个新的、名字还是叫作 web-0 的 Pod 来，“纠正”这个不一致的情况。

在这个新的 Pod 对象的定义里，它声明使用的 PVC 的名字，还是叫作：www-web-0。这个 PVC 的定义，还是来自于 PVC 模板（volumeClaimTemplates），这是 StatefulSet 创建 Pod 的标准流程。

所以，在这个新的 web-0 Pod 被创建出来之后，Kubernetes 为它查找名叫 www-web-0 的 PVC 时，就会直接找到旧 Pod 遗留下来的同名的 PVC，进而找到跟这个 PVC 绑定在一起的 PV。

这样，新的 Pod 就可以挂载到旧 Pod 对应的那个 Volume，并且获取到保存在 Volume 里的数据。



**Kubernetes 的 StatefulSet的工作原理如下** 

**首先，StatefulSet 的控制器直接管理的是 Pod**。StatefulSet 创建的Pod并不完全一致,有对应的编号

**其次，Kubernetes 通过 Headless Service，为这些有编号的 Pod，在 DNS 服务器中生成带有同样编号的 DNS 记录**

**最后，StatefulSet 还为每一个 Pod 分配并创建一个同样编号的 PVC**。这样，Kubernetes 就可以通过 Persistent Volume 机制为这个 PVC 绑定上对应的 PV，从而保证了每一个 Pod 都拥有一个独立的 Volume。

---



