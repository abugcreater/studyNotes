# 10.  深入解析声明式API

## API对象的奥秘

**声明式 API 的设计**

一个 API 对象在 Etcd 里的完整资源路径，是由：Group（API 组）、Version（API 版本）和 Resource（API 资源类型）三个部分组成的.

整个 Kubernetes 里的所有 API 对象，实际上就可以用如下的树形结构表示出来：



![k8s-10-1.png](../../img/k8s-10-1.png)

**Kubernetes 里 API 对象的组织方式，其实是层层递进的。**

示例YAML

```yaml
apiVersion: batch/v2alpha1 
kind: CronJob
...
```

其中`batch`就是group,`v2alpha1`就是版本号,`CronJob`就是资源类型

---

**Kubernetes 是如何对 Resource、Group 和 Version 进行解析**

**首先，Kubernetes 会匹配 API 对象的组。**

 Kubernetes 里的核心 API 对象是不需要Group 的,对于这些API对象Kubernetes 会直接在 /api 这个层级进行下一步的匹配过程。

非核心对象必须在/apis 这个层级里查找它对应的 Group.

一般对象以功能分组

**然后，Kubernetes 会进一步匹配到 API 对象的版本号。**

在 Kubernetes 中，同一种 API 对象可以有多个版本，这正是 Kubernetes 进行 API 版本化管理的重要手段。

**最后，Kubernetes 会匹配 API 对象的资源类型。**

流程图如下:

![k8s-10-2.png](../../img/k8s-10-2.png)

**首先**， APIServer 的第一个功能，就是过滤这个请求，并完成一些前置性的工作，比如授权、超时处理、审计等

**然后**，APIServer 使用MUX 和 Routes  完成 URL 和 Handler 绑定

**接着**，APIServer 会进行一个 Convert 工作，即：把用户提交的 YAML 文件，转换成一个叫作 Super Version 的对象,它正是该 API 资源类型所有版本的字段全集.该对象能处理不同版本的YAML文件

**接下来**，APIServer 会先后进行 Admission() 和 Validation() 操作

**最后**，APIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调用 Etcd 的 API 把它保存起来





//todo 自定义api server部分省略,目前只做了解











































