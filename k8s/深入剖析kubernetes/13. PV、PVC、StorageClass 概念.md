# 13. PV、PVC、StorageClass 概念

**PV 描述的，是持久化存储数据卷**:定义的是一个持久化存储在宿主机上的目录

**PVC 描述的，则是 Pod 所希望使用的持久化存储的属性**:Volume 存储的大小、可读写权限等等



PVC要和符合条件的PV绑定,必须要检查两部分:

-  PV 和 PVC 的 spec 字段。比如，PV 的存储（storage）大小
- PV 和 PVC 的 storageClassName 字段必须一样



PV和PVC绑定失败会导致Pod启动报错,那么修改PV自动重启Pod涉及到专门处理持久化存储的控制器(Volume Controller).这个controller维护多个循环,其中`PersistentVolumeController`用来处理PV和PVC的绑定.它会**不断检查未绑定的PVC并寻找可以匹配的PV与之绑定**.

---

**这个 PV 对象，又是如何变成容器里的一个持久化存储的**

**容器 Volume 的挂载机制,所谓容器的 Volume，其实就是将一个宿主机上的目录，跟一个容器里的目录绑定挂载在了一起。而所谓的“持久化 Volume”，指的就是这个宿主机上的目录，具备“持久性”**

> 持久性:目录中内容不会因为容器被删除而被清理,也不会跟当前宿主机绑定.容器重启后依然能够挂载到这个Volume

**这个准备“持久化”宿主机目录的过程，我们可以形象地称为“两阶段处理”。**

当pod调度到一个节点后,会初始化Pod的volume目录.默认宿主机路径是:

```sh
/var/lib/kubelet/pods/<Pod 的 ID>/volumes/kubernetes.io~<Volume 类型 >/<Volume 名字 >
```

**第一阶段称为Attach:为虚拟机挂载远程磁盘**

Attach 阶段完成后，为了能够使用这个远程磁盘，kubelet 还要进行第二个操作，即：格式化这个磁盘设备，然后将它挂载到宿主机指定的挂载点上。

类似如下命令:

```sh
# 通过 lsblk 命令获取磁盘设备 ID
$ sudo lsblk
# 格式化成 ext4 格式
$ sudo mkfs.ext4 -m 0 -F -E lazy_itable_init=0,lazy_journal_init=0,discard /dev/< 磁盘设备 ID>
# 挂载到挂载点
$ sudo mkdir -p /var/lib/kubelet/pods/<Pod 的 ID>/volumes/kubernetes.io~<Volume 类型 >/<Volume 名字 >
```

**第二阶段称为Mount:将磁盘设备格式化并挂载到 Volume 宿主机目录的操作**

Mount 阶段完成后，这个 Volume 的宿主机目录就是一个“持久化”的目录了，容器在它里面写入的内容，会保存在 Google Cloud 的远程磁盘中。



**Kubernetes 又是如何定义和区分这两个阶段的呢？**

其实很简单，在具体的 Volume 插件的实现接口上，Kubernetes 分别给这两个阶段提供了两种不同的参数列表：

- 对于“第一阶段”（Attach），Kubernetes 提供的可用参数是 nodeName，即宿主机的名字。
- 而对于“第二阶段”（Mount），Kubernetes 提供的可用参数是 dir，即 Volume 的宿主机目录。

> 在删除一个 PV 的时候，Kubernetes 也需要 Unmount 和 Dettach 两个阶段来处理。这个过程，执行“反向操作”即可。



 **PV 的“两阶段处理”流程，是靠独立于 kubelet 主控制循环（Kubelet Sync Loop）之外的两个控制循环来实现的。**

第一阶段”的 Attach（以及 Dettach）操作，是由 Volume Controller 负责维护的，这个控制循环的名字叫作：**AttachDetachController**。他是kube-controller-manager 的一部分,运行在master节点 而它的作用，就是不断地检查每一个 Pod 对应的 PV，和这个 Pod 所在宿主机之间挂载情况。从而决定，是否需要对这个 PV 进行 Attach（或者 Dettach）操作。

“第二阶段”的 Mount（以及 Unmount）操作，必须发生在 Pod 对应的宿主机上，所以它必须是 kubelet 组件的一部分。这个控制循环的名字，叫作：**VolumeManagerReconciler**，它运行起来之后，是一个独立于 kubelet 主循环的 Goroutine。

---

人工管理的方式称之为: Static Provisioning.而Kubernetes 提供了自动创建PV的机制`Dynamic Provisioning`.这套机制的核心在于API对象` StorageClass `

**而 StorageClass 对象的作用，其实就是创建 PV 的模板。**

StorageClass 对象会定义如下两个部分内容：

- 第一，PV 的属性。比如，存储类型、Volume 的大小等等。
- 第二，创建这种 PV 需要用到的存储插件。比如，Ceph 等等。

对象定义如下所示:

```yaml
apiVersion: ceph.rook.io/v1beta1
kind: Pool
metadata:
  name: replicapool
  namespace: rook-ceph
spec:
  replicated:
    size: 3
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: block-service
provisioner: ceph.rook.io/block
parameters:  
  pool: replicapool
  #The value of "clusterNamespace" MUST be the same as the one in which your rook cluster exist
  clusterNamespace: rook-ceph
```

定义的是一个名叫 block-service 的 StorageClass，只不过它声明使的存储插件是由 Rook 项目

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: claim1
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: block-service
  resources:
    requests:
      storage: 30Gi
```

使用者需要在PVC中使用storageClassName 字段指定StorageClass

**Kubernetes 只会将 StorageClass 相同的 PVC 和 PV 绑定起来**



如果你的集群已经开启了名叫 DefaultStorageClass 的 Admission Plugin，它就会为 PVC 和 PV 自动添加一个默认的 StorageClass；**否则，PVC 的 storageClassName 的值就是“”，这也意味着它只能够跟 storageClassName 也是“”的 PV 进行绑定。**

----

PV,PVC与StorageClass关系如下图所示:

![k8s-13-2.png](../../img/k8s-13-2.png)

- PVC 描述的，是 Pod 想要使用的持久化存储的属性，比如存储的大小、读写权限等。
- PV 描述的，则是一个具体的 Volume 的属性，比如 Volume 的类型、挂载目录、远程存储服务器地址等。
- 而 StorageClass 的作用，则是充当 PV 的模板。并且，只有同属于一个 StorageClass 的 PV 和 PVC，才可以绑定在一起。































