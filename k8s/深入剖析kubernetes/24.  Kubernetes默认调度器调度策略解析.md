# 24.  Kubernetes默认调度器调度策略解析

**Predicates**

**Predicates 在调度过程中的作用，可以理解为 Filter,**它会按照策略,从集群所有节点汇总,过滤出符合条件的节点.

在 Kubernetes 中，默认的调度策略有如下三种:

**第一种类型，叫作 GeneralPredicates(一般性预测)。**

负责最基础的调度策略,判断硬件资源是否够用. 

Kubernetes 调度器会为硬件资源同事使用Extended Resource 的key-value扩展格式描述.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: extended-resource-demo
spec:
  containers:
  - name: extended-resource-demo-ctr
    image: nginx
    resources:
      requests:
        alpha.kubernetes.io/nvidia-gpu: 2
      limits:
        alpha.kubernetes.io/nvidia-gpu: 2
```

在上面这个例子中,Pod通过`alpha.kubernetes.io/nvidia-gpu=2`声明使用两个NVIDIA类型的GPU.

PodFitsResources 里面,会通过一系列的流程检查,比如PodFitsHost 检查宿主机名称,PodFitsHostPorts 检查宿主机端口,PodMatchNodeSelector 检查nodeSelector .

**第二种类型，是与 Volume 相关的过滤规则。**

这组过滤规则,负责的是跟容器持久化Volume 相关的调度策略.

NoDiskConflict 检查多个Pod声明挂载的持久化Volume 是否有冲突

MaxPDVolumeCountPredicate 检查,某个节点上某种类型的持久化Volume 是不是已经超过一定的数目

VolumeZonePredicate，则是检查持久化 Volume 的 Zone（高可用域）标签

**第三种类型，是宿主机相关的过滤规则。**

比如，PodToleratesNodeTaints，负责检查的就是我们前面经常用到的 Node 的“污点”机制。只有当 Pod 的 Toleration 字段与 Node 的 Taint 字段能够匹配的时候，这个 Pod 才能被调度到该节点上。

**第四种类型，是 Pod 相关的过滤规则。**

这组规则中比较特殊的是PodAffinityPredicate,用来检查待调度 Pod 与 Node 上的已有 Pod 之间的亲密（affinity）和反亲密（anti-affinity）关系

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: with-pod-antiaffinity
spec:
  affinity:
    podAntiAffinity: # 反亲密校验
      requiredDuringSchedulingIgnoredDuringExecution: 
      - weight: 100  
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: security 
              operator: In 
              values:
              - S2
          topologyKey: kubernetes.io/hostname
  containers:
  - name: with-pod-affinity
    image: docker.io/ocpqe/hello-pod
```

指定了这个 Pod 不希望跟任何携带了 security=S2 标签的 Pod 存在于同一个 Node 上.规则作用域是携带了 Key 是`kubernetes.io/hostname`标签的 Node .

上面这个例子里的 `requiredDuringSchedulingIgnoredDuringExecution` 字段的含义是：这条规则必须在 Pod 调度时进行检查（requiredDuringScheduling）.当已经运行的Pod发生变化时,Kubernetes不会主动修正(IgnoredDuringExecution)



**在具体执行的时候， 当开始调度一个 Pod 时，Kubernetes 调度器会同时启动 16 个 Goroutine(协程)，来并发地为集群里的所有 Node 计算 Predicates，最后返回可以运行这个 Pod 的宿主机列表。**

> 调度器会按照固定的顺序来进行检查。这个顺序，是按照 Predicates 本身的含义来确定的。

---

**Priorities**

Priorities 里最常用到的一个打分规则，是 LeastRequestedPriority。它的计算方法，可以简单地总结为如下所示的公式：

```
score = (cpu((capacity-sum(requested))10/capacity) + memory((capacity-sum(requested))10/capacity))/2
```

算法实际上就是在选择空闲资源（CPU 和 Memory）最多的宿主机

与 LeastRequestedPriority 一起发挥作用的，还有BalancedResourceAllocation它的计算公式如下所示：

```
score = 10 - variance(cpuFraction,memoryFraction,volumeFraction)*10
```

每种资源的 Fraction 的定义是 ：Pod 请求的资源 / 节点上的可用资源。而 variance 算法的作用，则是计算每两种资源 Fraction 之间的“距离”。而最后选择的，则是资源 Fraction 差距最小的节点.

BalancedResourceAllocation选择的是每种资源最均衡的节点.

在默认 Priorities 里，还有一个叫作 ImageLocalityPriority 的策略。它是在 Kubernetes v1.12 里新开启的调度规则，即：如果待调度 Pod 需要使用的镜像很大，并且已经存在于某些 Node 上，那么这些 Node 的得分就会比较高。

**在实际的执行过程中，调度器里关于集群和 Pod 的信息都已经缓存化，所以这些算法的执行过程还是比较快的。**

































































