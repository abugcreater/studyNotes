# 20. 从外界连通Service与Service调试

**如何从外部（Kubernetes 集群之外），访问到 Kubernetes 里创建的 Service？**

最常用的一种方式就是：NodePort

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  labels:
    run: my-nginx
spec:
  type: NodePort
  ports:
  - nodePort: 8080
    targetPort: 80
    protocol: TCP
    name: http
  - nodePort: 443
    protocol: TCP
    name: https
  selector:
    run: my-nginx
```

service的8080端口代理pod的80端口,service的443端口代理pod的443端口

如果不显式声明 nodePort 字段,会根据kube-apiserver 的–service-node-port-range 参数来随机分配端口,默认值为 30000-32767

之歌时候只要访问

```
< 任何一台宿主机的 IP 地址 >:8080
```

地址,就能访问到某个被代理的Pod的80端口

NodePort 就是在每台宿主机上生成这样一条 iptables 规则：

````
-A KUBE-NODEPORTS -p tcp -m comment --comment "default/my-nginx: nodePort" -m tcp --dport 8080 -j KUBE-SVC-67RL4FN6JRUPOJYM
````

在 NodePort 方式下，Kubernetes 会在 IP 包离开宿主机发往目的 Pod 时，对这个 IP 包做一次 SNAT 操作，如下所示：

```
-A KUBE-POSTROUTING -m comment --comment "kubernetes service traffic requiring SNAT" -m mark --mark 0x4000/0x4000 -j MASQUERADE
```

规则设置在POSTROUTING检查点上,对即将离开的IP包进行SNAT转换,IP包的源地址替换宿主机上的CNI网桥地址或者宿主机本身.

**替换原因如下:**

```
         client
             \ ^
              \ \
               v \
   node 1 <--- node 2
    | ^   SNAT
    | |   --->
    v |
 endpoint
```

node2 将包转发给node1,当node1响应时如果没有替换,就会直接发送给client.而client因为回复的对象IP地址错误而拒绝. 

而经过转换后node1会将包转发给node2,最终发送到client.



我们可以设置 Service 的 spec.externalTrafficPolicy 字段设置为 local，这就保证了所有 Pod 通过 Service 收到请求之后，一定可以看到真正的、外部 client 的源地址

**这时候，一台宿主机上的 iptables 规则，会设置为只将 IP 包转发给运行在这台宿主机上的 Pod**。

------------

从外部访问 Service 的第二种方式，**适用于公有云上的 Kubernetes 服务**。这时候，你可以指定一个 LoadBalancer 类型的 Service，如下所示：

```yaml
---
kind: Service
apiVersion: v1
metadata:
  name: example-service
spec:
  ports:
  - port: 8765
    targetPort: 9376
  selector:
    app: example
  type: LoadBalancer
```

在 LoadBalancer 类型的 Service 被提交后，Kubernetes 就会调用 CloudProvider 在公有云上为你创建一个负载均衡服务，并且把被代理的 Pod 的 IP 地址配置给负载均衡服务做后端。

----

第三种方式，是 Kubernetes 在 1.7 之后支持的一个新特性，叫作 **ExternalName**

```yaml
kind: Service
apiVersion: v1
metadata:
  name: my-service
spec:
  type: ExternalName
  externalName: my.database.example.com
```

这个service并没有指定selector,当使用service的DNS名称访问时,它会访问externalName.

ExternalName 类型的 Service，其实是在 kube-dns 里为你添加了一条 CNAME 记录。这时，访问 my-service.default.svc.cluster.local 就和访问 my.database.example.com 这个域名是一个效果了

----

Kubernetes 的 Service 还允许你为 Service 分配公有 IP 地址，比如下面这个例子：

```yaml
kind: Service
apiVersion: v1
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: 9376
  externalIPs:
  - 80.11.12.10
```

我为它指定的 externalIPs=80.11.12.10，那么此时，你就可以通过访问 80.11.12.10:80 访问到被代理的 Pod 了。不过，在这里 Kubernetes 要求 externalIPs 必须是至少能够路由到一个 Kubernetes 的节点。

**在理解了 Kubernetes Service 机制的工作原理之后，很多与 Service 相关的问题，其实都可以通过分析 Service 在宿主机上对应的 iptables 规则（或者 IPVS 配置）得到解决**



































引用:[SNAT和DNAT](https://juejin.cn/post/7144679982759936013)

[Linux bridge hairpin mode](https://zhuanlan.zhihu.com/p/399798447)