# 15. 深入解析容器跨主机网络

 Flannel的后端为我们提供了容器网络功能,解决跨主同行.目前支持三种后端实现: VXLAN,host-gw,UDP.

其中UDP是最直接也最容易被理解的容器跨主网络实现,但是性能也是最差的.

----

假设有两台宿主机:

- 宿主机 Node 1 上有一个容器 container-1，它的 IP 地址是 100.96.1.2，对应的 docker0 网桥的地址是：100.96.1.1/24。
- 宿主机 Node 2 上有一个容器 container-2，它的 IP 地址是 100.96.2.3，对应的 docker0 网桥的地址是：100.96.2.1/24。



当容器1访问容器2时,发出的IP包源地址就是100.96.1.2,目标地址是100.96.2.3,但是100.96.2.3并不在Node1的docker0网桥的网段里,所以这个IP包会交给默认路由规则,交由宿主机处理.

此时Flannel在宿主机Node1创建的路由规则如下:

```sh
# 在 Node 1 上
$ ip route
default via 10.168.0.1 dev eth0
100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.1.0
100.96.1.0/24 dev docker0  proto kernel  scope link  src 100.96.1.1
10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.2
```

只能匹配到第一条规则,进入flannel0的设备中.flannel0是一个TUN(Tunnel)设备

> TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备。TUN 设备的功能非常简单，即：**在操作系统内核和用户应用程序之间传递 IP 包**

flannel0会把IP包交给创建该设备的应用程序,也就是 Flannel 进程.此时是从内核态想用户态转换.

反之，如果 Flannel 进程向 flannel0 设备发送了一个 IP 包，那么这个 IP 包就会出现在宿主机网络栈中，然后根据宿主机的路由表进行下一步处理。这是一个从用户态向内核态的流动方向。

当IP包进入flannel0 设备后, flanneld 进程看到目的地址后会把他发送个Node2的宿主机.

**flanneld 又是如何知道这个 IP 地址对应的容器**

在由 Flannel 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的一个“子网”。比如例子中，Node 1 的子网是 100.96.1.0/24,而这些子网与宿主机的关系就保存在Etcd中:

```sh
$ etcdctl ls /coreos.com/network/subnets
/coreos.com/network/subnets/100.96.1.0-24
/coreos.com/network/subnets/100.96.2.0-24
/coreos.com/network/subnets/100.96.3.0-24
```

经过子网匹配就能找到Node2的地址.

flanneld 在收到包后,会把这个IP包封装在UDP包里发送个Node2.这个UDP包的源地址就是Node1的地址,而目的地址就是Node2的地址.

flanneld 在每台宿主机上都监听者8285端口,当UDP包大道是,flanneld 就可以从这个 UDP 包里解析出封装在里面的、container-1 发来的原 IP 包.然后将IP包发送给TUN设备.经过本机路由表匹配规则后转发给docker0网桥.

docker0 网桥会扮演二层交换机的角色，将数据包发送给正确的端口，进而通过 Veth Pair 设备进入到 container-2 的 Network Namespace 里

以上，就是基于 Flannel UDP 模式的跨主通信的基本原理了。我把它总结成了一幅原理图，如下所示。

![k8s-15-1.png](../../img/k8s-15-1.png)



Flannel UDP 模式提供的其实是一个三层的 Overlay 网络:对发出端IP包进行UDP封装,然后在接收端解封装,进而转发到标准容器.使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况

但是由于UDP模式的有严重的性能问题.在这个模式的通信过程中,由于使用到了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝，如下所示：

![k8s-15-2.png](../../img/k8s-15-2.png)

第一次：用户态的容器进程发出的 IP 包经过 docker0 网桥进入内核态；

第二次：IP 包根据路由表进入 TUN（flannel0）设备，从而回到用户态的 flanneld 进程；

第三次：flanneld 进行 UDP 封包之后重新进入内核态，将 UDP 包通过宿主机的 eth0 发出去。

存在频繁的上下文切换.上述这些上下文切换和用户态操作的代价其实是比较高的，这也正是造成 Flannel UDP 模式性能不好的主要原因。

**我们在进行系统级编程的时候，有一个非常重要的优化原则，就是要减少用户态到内核态的切换次数，并且把核心的处理逻辑都放在内核态进行**。

---

VXLAN，即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。它能在内核态实现封装和解封装工作,构件overlay network.

VXLAN 的覆盖网络的设计思想是：在现有的三层网络之上，“覆盖”一层虚拟的、由内核 VXLAN 模块负责维护的二层网络，使得连接在这个 VXLAN 二层网络上的“主机”（虚拟机或者容器都可以）之间，可以像在同一个局域网（LAN）里那样自由通信。

而为了能够在二层网络上打通“隧道”,VXLAN 会在宿主机上设置一个特殊的网络设备VTEP作为隧道两端,即：VXLAN Tunnel End Point（虚拟隧道端点）

VTEP 设备的作用，其实跟前面的 flanneld 进程非常相似.只不过对象变成了二层数据帧（Ethernet frame）,且执行流程全部在内核里完成.

**基于 VTEP 设备进行“隧道”通信的流程**

![k8s-15-3.png](../../img/k8s-15-3.png)

图中每台宿主机上名叫 flannel.1 的设备，就是 VXLAN 所需的 VTEP 设备,它既有IP地址也有MAC地址.

当容器1发送请求后,也会被转到flannel.1设备处理,也就是来到了隧道入口.

为了能够将“原始 IP 包”封装并且发送到正确的宿主机，VXLAN 就需要找到这条“隧道”的出口，即：目的宿主机的 VTEP 设备。

而这个设备的信息，正是每台宿主机上的 flanneld 进程负责维护的。

当Node2加入Flannel 网络后,Node1（以及所有其他节点）上，flanneld 就会添加一条如下所示的路由规则：

```sh
$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
...
10.1.16.0       10.1.16.0       255.255.255.0   UG    0      0        0 flannel.1
```

表示发往10.1.16.0/24网段的IP包,都需要经过flannel.1发出,网关地址是10.1.16.0

 VTEP 设备之间需要想办法组成一个虚拟的二层网络,即：通过二层数据帧进行通信.所以我们需要将原始IP包加上目标MAC地址,封装成一个二层数据帧,然后发送给目标VTEP设备.

**“目的 VTEP 设备”的 MAC 地址是什么**

我们已经有了目标VTEP的IP地址,可以通过 ARP（Address Resolution Protocol ）表的功能查询.

有了这个“目的 VTEP 设备”的 MAC 地址，**Linux 内核就可以开始二层封包工作了**。二层帧格式如下:

![k8s-15-4.png](../../img/k8s-15-4.png)



上述封包过程只是加一个二层头，不会改变“原始 IP 包”的内容。所以图中的 Inner IP Header 字段，依然是 container-2 的 IP 地址

为了该数据帧能在宿主机二层网络里传输,Linux 内核还需要再把“内部数据帧”进一步封装成为宿主机网络里的一个普通的数据帧

Linux 内核会在“内部数据帧”前面，加上一个特殊的 VXLAN 头,该头部有一个重要的标志叫做**VNI**，它是 VTEP 设备识别某个数据帧是不是应该归自己处理的重要标识。在Flannel中,默认是1,所以宿主机上的 VTEP 设备都叫作 flannel.1 的原因，这里的“1”，其实就是 VNI 的值

**然后，Linux 内核会把这个数据帧封装进一个 UDP 包里发出去。**

但是此时我们还不知道对应宿主机的MAC地址,flannel.1 设备还需要扮演一个网桥的角色,在二层网络进行UDP包转发.转发依据来自于FDB（Forwarding Database）转发数据库.

```sh
# 在 Node 1 上，使用“目的 VTEP 设备”的 MAC 地址进行查询
$ bridge fdb show flannel.1 | grep 5e:f8:4f:00:e3:37
5e:f8:4f:00:e3:37 dev flannel.1 dst 10.168.0.3 self permanent
```

所以**接下来的流程，就是一个正常的、宿主机网络上的封包工作。**

我们知道，UDP 包是一个四层数据包，所以 Linux 内核会在它前面加上一个 IP 头，即原理图中的 Outer IP Header，组成一个 IP 包。并且，在这个 IP 头里，会填上前面通过 FDB 查询出来的目的主机的 IP 地址，即 Node 2 的 IP 地址 10.168.0.3。

然后，Linux 内核再在这个 IP 包前面加上二层数据帧头，即原理图中的 Outer Ethernet Header，并把 Node 2 的 MAC 地址填进去。这个 MAC 地址本身，是 Node 1 的 ARP 表要学习的内容，无需 Flannel 维护。这时候，我们封装出来的“外部数据帧”的格式，如下所示：

![k8s-15-5.png](../../img/k8s-15-5.png)



这样，封包工作就宣告完成了。

























