## codis 

codis 国人开发的Redis集群方案,由codis server,codis proxy,zookeenper集群和codis dashboard组成.

codis server:实际存储数据的实例,基于Redis 做了二开,数据类型不如Redis丰富

codis proxy:接受客户端请求并转发,转发给codis server

zookeeper:用于保存集群元数据

dashboard 和fe:是管理工具

为了保证codis的高可用,codis也支持部署多个codis实例,能增加集群的qps.

codis只是一个代理中间件,具体的读写还是通过Redis实例(codis server)实现,可以通过增加Redis实例完成海量的数据存储及高并发读写.他需要将特定的key转发到特定的Redis实例中.

codis默认分成1024个槽位(slot),首先对客户端传过来的key进行[crc32](https://www.cnblogs.com/masonzhang/p/10261855.html)取哈希值,再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。codis会维护槽位和实例间的关系.多实例间信息同步是通过zk/etcd实现.

当集群扩容时,例如之前只有一个节点,现在扩容到多个节点,可以通过dashboard添加,然后将槽位重新分配,完成数据迁移. codis迁移时是以槽位为基础进行迁移.

codis有自动平衡机制,在系统比较空闲时会观城Redis分配实例情况,如果不平衡则会迁移

优点:集群简单,分布式由ZK解决,拥有可视化的dashboard,还有codis-fe工具可以对多个codis集群进行管理.

缺点:不支持事务,因为多个key在迁移时可能在不同的实例上,部分命令不支持,集合过大会导致迁移卡顿,网络开销较大,新增了proxy作为中转层

## redis cluster

redis cluster是Redis官方提供的集群方案,去中心化,混合使用了raft和gossip协议.redis cluster将所有数据分为16384个槽位,在槽位分配完毕之前集群无法工作.key的槽位分配也是crc32取hash后对16384取模.

当客户端建立连接后客户端会得到一份槽位配置信息,客户端可以直接访问key所在的节点.当客户想错误的节点发送数据时,客户端会发送一个move指令后面会带key目前所在的节点地址.如果集群此时正在迁移,则会返回ack错误.

cluster可以根据tag取模,所以可以指定key保存在某个槽位上.

cluster可以通过手动迁移.集群可以与主从同时使用保证高可用.

## 主从

主从模式官方解决方案是哨兵(redis sentinel).

哨兵通过周期性的ping主从节点获取节点的健康状态.当主节点宕机时会挑选一个最优的从节点切换到主节点,然后主从节点需要从新同步.

哨兵判断下线包括主观下线和客观下线.主观下线指PING超时只要有一个哨兵判断其下线.客观下线指超过半数的哨兵判断其已经主观下线.

当主节点下线后哨兵开始选新的主节点.首先先要筛选出网络状态良好的从节点.然后经过三轮打分,取得分最高的节点.

第一轮:获取节点优先级,先取优先级高的节点,如果有同样高优先级的节点则进行第二轮

第二轮:获取从节点的同步状态,先取复制进度最接近主库的节点,如果有多个则进入第三轮

第三轮:从第二轮获胜的从库中获取从库编号,取最小的那个



客户端连接时优先想哨兵获取主节点的信息,然后连接到主节点,主节点挂了后会重新要主节点信息

从库通过在主库上发布自己的信息,并订阅该队列,获取到所有从库信息就可以实现互相发现.哨兵通过想主库发送INFO命令获取到从库信息

![image-20220511163738198](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220511163738198.png)

客户端通过订阅哨兵频道获取信息.



哨兵集群通过raft协议进行选举.

哨兵实例越多，通信的次数也就越多,网络开销越大.







