## 容器技术中的网络

### 容器网络

封闭环境主要使用到了namespace技术和cgroup技术

**命名空间（namespace）**

namespace用于隔离不同资源,防止进程冲突,可以用ip netns命令增删查.namespace中的网络实现如下图:

![](..\img\network-protocol-29-1.jpg)



我们需要创建一个虚拟路由器router链接外部网络,router需要开启转发功能,并设置转发规则,虚拟机需要新增一张网卡来连接网桥br0与router.为了访问外网我们还需要另一张网卡连在br-ex上.

虚拟机访问外网需要通过NAT转换.

**机制网络（cgroup）**

cgroup 全称 control groups，是 Linux 内核提供的一种可以限制、隔离进程使用的资源机制。

比如:net_cls，这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包

![](..\img\network-protocol-29-2.jpg)

我们可以设定命令让网络包分流,比如根据端口,分流到 1:10中

**容器网络中如何融入物理网络？**

![](..\img\network-protocol-29-3.jpg)

docker容器的内外都有网卡,连接到网桥上,通过网桥互相访问.

容器访问外网,利用NAT模式,通过地址伪装,将IP地址转换为物理机IP地址,然后在conntrack 中记录.传输流程如下图所示:

![](..\img\network-protocol-29-4.jpg)

Docker 有两种方式，一种是通过一个进程**docker-proxy**的方式，监听 10080，转换为 80 端口

另外一种方式是通过**DNAT**方式，在 -A PREROUTING 阶段加一个规则，将到端口 10080 的 DNAT 称为容器的私有网络

---

###  容器网络之Flannel

基于 NAT 的容器网络模型在微服务架构下有两个问题，一个是 IP 重叠，一个是端口冲突，需要通过 Overlay 网络的机制保持跨节点的连通性

 **Flannel 使用 UDP 实现 Overlay 网络的方案**

![](..\img\network-protocol-30-1.jpg)

当容器A需要将请求发往容器B时,会先将包发送到网关 172.17.8.1,然后根据路由表的规则 发往172.17.9.0/24网段的包会发送到flannel.1. 

这个flannel.1设备也是和之前云中网络的 qemu-kem类似,打开 /dev/net/tun设备出现的网卡.

所有发送到flannel.1的包都会被flanneld进程读取并处理.

物理机 A 上的 flanneld 会将网络包封装在 UDP 包里面，然后外层加上物理机 A 和物理机 B 的 IP 地址，发送给物理机 B 上的 flanneld。

物理机B上收到包后,将包打卡经过路由表匹配后会将发送到docker0,之后转给容器B.

> 使用UDP的原因在于不想再两台机器中建立连接



除了上述方案外,也可以使用VXLAN方式建立通信.

![](..\img\network-protocol-30-2.jpg)



当网络包从物理机 A 上的容器 A 发送给物理机 B 上的容器 B，在容器 A 里面通过默认路由到达物理机 A 上的 docker0 网卡，然后根据路由规则，在物理机 A 上，将包转发给 flannel.1。这个时候 flannel.1 就是一个 VXLAN 的 VTEP 了，它将网络包进行封装.添加源MAC地址和目标MAC地址,添加源IP地址和目标IP地址.

这样就能通过 VXLAN 将包转发到另一台机器，从物理机 B 的 flannel.1 上解包，变成内部的网络包，通过物理机 B 上的路由转发到 docker0，然后转发到容器 B 里面。通信成功。

---

### 容器网络之Calico

**Calico设计思路**

Calico 网络的大概思路，即不走 Overlay 网络，不引入另外的网络性能损耗，而是将转发全部用三层网络的路由转发来实现.

利用物理机充当路由器,所以整个拓扑结构如下:

![](..\img\network-protocol-31-1.jpg)

**Calico 网络的转发细节**

A1的IP 地址为 172.17.8.2/32,配置路由是:

```
default via 169.254.1.1 dev eth0 
169.254.1.1 dev eth0 scope link 
```

因为网关的IP地址不会再任何网络包头里面出现,所以虽然这个地址不存在,但是无关紧要,只要能提供MAC地址就行.

ARP 本地有缓存，通过 ip neigh 命令可以查看。

```
169.254.1.1 dev eth0 lladdr ee:ee:ee:ee:ee:ee STALE
```

veth1就是这个MAC地址,从A1发出的网络包第一条就是veth1网卡,就到达物理机A的路由器.

物理机A上有三条路由规则:

```
172.17.8.2 dev veth1 scope link 
172.17.8.3 dev veth2 scope link 
172.17.9.0/24 via 192.168.100.101 dev eth0 proto bird onlink
```

引导网络包下一条为物理机B.物理机B也有类似的路由规则,转化为拓扑图如下:

![](..\img\network-protocol-31-2.jpg)

**Calico 的架构**

**路由配置组件 Felix**

当存在多个容器时,由于容器不断变更,每个容器间都要两两配置路由,

在Calico 中会在每个物理机上安装agent Felix,用来自动配置路由.

**路由广播组件 BGP Speaker**

在 Calico 中，每个 Node 上运行一个软件 BIRD，作为 BGP 的客户端，或者叫作 BGP Speaker,将路由信息广播出去.所有 Node 上的 BGP Speaker 都互相建立连接，就形成了全互连的情况，这样每当路由有所变化的时候，所有节点就都能够收到了

**安全策略组件**

Calico 中也是用 iptables 实现的,会在这些点上设置相应规则.

![](..\img\network-protocol-31-3.jpg)

Calico 的所有组件的汇总图如下:

![](..\img\network-protocol-31-4.jpg)

**全连接复杂性与规模问题**

BGP Route Reflector基于BIRD 实现,BGP Speaker 就不用全互连了，而是都直连它，它负责将全网的路由信息广播出去.但是如果所有节点都连他,他就会成为瓶颈,所以我们可以仿照数据中心的模式.将节点分区,每个分区链接一个BGP Route Reflector,BGP Route Reflector之间互相链接.

![](..\img\network-protocol-31-5.jpg)

**跨网段访问问题**

如果两个物理机分布在不同的网段上,那么相互访问就需要经过中间路由.那么物理机A就无法知道下一跳是谁.

Calico 利用IPIP模式,在两台物理机上打通隧道,这样不管外层的 IP 通过传统的物理网络，走多少跳到达目标物理机，从隧道两端看起来，物理机 A 的下一跳就是物理机 B，这样前面的逻辑才能成立。

使用了 IPIP 模式之后，在物理机 A 上，我们能看到这样的路由表：

```
172.17.8.2 dev veth1 scope link 
172.17.8.3 dev veth2 scope link 
172.17.9.0/24 via 192.168.200.101 dev tun0 proto bird onlink
```











