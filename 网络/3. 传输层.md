## 传输层

### UDP协议

**TCP和UDP的区别**

TCP 是面向连接的，UDP 是面向无连接的

建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性

TCP提供可靠交付,UDP不保证不丢失,不保证按顺序

TCP面向字节流,UDP基于数据报

TCP有拥塞控制,UDP没有

TCP是由状态服务,UDP时无状态服务

**UDP包头**

![](../img/network-protocol-10-1.jpg)

**UDP的特点和使用场景**

报文简单:可以使用在需要资源少,网络情况较好的内网,或者对丢包不敏感的应用

不会建立连接:可以广播应用

没有拥塞控制:需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候

---

### TCP协议

**TCP包头格式**

![](../img/network-protocol-11-1.jpg)

URG~FIN 时状态为,达标连接状态,发送带状态位的包会引起双方状态变更.

窗口大小用于流量控制

**三次握手**

三次握手用于建立连接和沟通TCP包的序号,第三次握手能确认对方的接收能力.

![](../img/network-protocol-11-2.jpg)

**四次挥手**

四次挥手时等待时间为2MSL.

**MSL**是**Maximum Segment Lifetime**，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

![](../img/network-protocol-11-3.jpg)

**TCP 状态机**

虚线内容为非主干

![](../img/network-protocol-11-4.jpg)

**应答**

TCP使用**累计应答**（**cumulative acknowledgment**）来应答之前收到的包.

为了记录发送和接收的包,TCP发送端和接收端分别要缓存保存这些记录

![](../img/network-protocol-12-1.jpg)

TCP发送端分为如图所示四部分.接收端会给发送端报一个窗口的大小，叫**Advertised window**

这个窗口打下为 第二部分加上第三部分.

![](../img/network-protocol-12-2.jpg)

接收端相对简单:

- MaxRcvBuffer：最大缓存的量；
- LastByteRead 之后是已经接收了，但是还没被应用层读取的；
- NextByteExpected 是第一部分和第二部分的分界线。

`AdvertisedWindow=MaxRcvBuffer-((NextByteExpected-1)-LastByteRead)`

**顺序与丢包**

以上图为例,假设5的ACK丢了,6,7的包丢了,此时该怎么办?

此时的一种解决办法就是**超时重试**,对于没有ACK的包定时重传.对于重传时间需要根据**自适应重传算法**（**Adaptive Retransmission Algorithm**）计算. TCP的策略时**超时间隔加倍**

还有一种办法是**Selective Acknowledgment** （**SACK**）,ACK返回缓存的地图,如ACK6,ACK8发送方可以马上发现 7 丢了.

**流量控制**

当窗口大小固定,当发送方发送过快时,可能会导致第三部分大小为0.

接收方可以通过确认信息修改窗口大小,如果设置为0,则发送方将停止发送.如果设置为0,发送方会定时发送窗口探测数据包,看是否调整窗口大小.

**拥塞控制**

通过窗口大小控制,前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满.且`LastByteSent - LastByteAcked <= min {cwnd, rwnd} `

TCP 的拥塞控制主要来避免两种现象，**包丢失**和**超时重传**。一旦出现了这些现象就说明，发送速度太快了，要慢一点。

TCP通过慢启动实现发送的指数级增长,1->2->4->8以此类推,当到达阈值 ssthresh 为 65535字节时,变成现行增长.

当出现丢包时,如果丢包较少则使用**快速重传**, cwnd 减半,然后sshthresh = cwnd,当这些包返回时 cwnd = sshthresh + n.如下图所示:

![](../img/network-protocol-12-3.jpg)



---

### 套接字Socket

**基于 TCP 协议的 Socket 程序函数调用过程**

TCP需要监听端口,然后配置IP选择监听网卡,之后选择listen函数进行监听,socket维护两个队列,建立连接的队列;还未建立连接 syn_rcvd状态的队列.

一旦握手成功，服务端的 accept 就会返回另一个 Socket。就是监听的 Socket 和真正用来传数据的 Socket 是两个，一个叫作**监听 Socket**，一个叫作**已连接 Socket**。

调用过程如下图:

![](../img/network-protocol-13-1.jpg)

socket在内核中的数据结构如下:

![](../img/network-protocol-13-2.jpg)

**基于 UDP 协议的 Socket 程序函数调用过程**

UDP不需要连接,但是任然需要IP和端口,调用过程如下图

![](../img/network-protocol-13-3.jpg)







