通道整理:



## 项目初始化

首先看项目初始化时干了啥 

initrunner 类做了三件事. 1. 清除现有统计信息 2. 初始化所有端点类.  3. 初始化socket服务

清理缓存是删除Redis中所有缓存信息

第二个是初始化所有端点类

该功能由DefaultEndpointMapper 负责.

启动时 DefaultEndpointMapper 继承 ApplicationObjectSupport 用于获取上下文容器.

实现了EndpointMapper的init方法,用于在初始化时扫描所有端点类.init方法如下

```java
public void init() {
    ApplicationContext context = getApplicationContext();
    // 6个默认端点，按0.75扩容两次后是18.375，故在此凑整预留20,存放对应的端点key格式appid-endpointName 
    pointMapper = new ConcurrentHashMap<>(20);
    // 目前使用的只有3个appId，再加上默认的实现，所以容量初始化为4,存放对应的实例
    instanceMapper = new ConcurrentHashMap<>(4);
    try {
        // 找出所有@Endpoints注解的，需要注册端点的类的名称 @Endpoints 引入了@compent注解,在启动时所有类已经有spring管理
        String[] endpointBeanNames = context.getBeanNamesForAnnotation(Endpoints.class);
        Set<Class<?>> endpointClasses = new HashSet<>(endpointBeanNames.length);
        // 获取每个类的Class，后面需要遍历类内方法
        for (String beanName : endpointBeanNames) {
            endpointClasses.add(context.getType(beanName));
        }
        for (Class<?> endpointClass : endpointClasses) {
            // 注册每一个类内的端点
            registerEndpoints(context, endpointClass);
        }
    } catch (Exception e) {
        log.error("endpoints init Error!", e);
        System.exit(0);
    }
}
```

每个endpoints对应不同的应用,处理该应用中的不同操作.每个类中又有下列注解对应的方法,代表不同的网络请求.

```Java
String ON_OPEN = "onOpen"; //打开连接
String ON_CLOSE = "onClose"; //关闭连接
String ON_EVENT = "onEvent"; //触发事件
String ON_BINARY = "onBinary"; 
String ON_ERROR = "onError";
String ON_MESSAGE = "onMessage"; //消息
String ON_COMMAND = "onCommand"; /推送
```

第三件事 初始化socket服务



## 业务流转

定义了NettyServerHandler类去实际处理相关的连接消息

覆盖了父类中的相关方法,去做了特定的业务处理,核心处理逻辑如下

```java
protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
    //传统的HTTP接入,值得一提的是websocket建立连接也是调用FullHttpRequest类型
    if (msg instanceof FullHttpRequest) {
        //获取头部参数
        FullHttpRequest fhr = (FullHttpRequest) msg;
        //通过路径及头部参数做权限校验
        String auth = fhr.headers().get("Auth");
        final String path = fhr.uri();
        boolean validate;
        Map<String, String> maps = URLUtil.parse(path).params;
        //允许token登录
        if (maps != null && maps.containsKey(TOKEN) && maps.containsKey(USER_ID)) {
            if (ADMIN_TOKEN.equals(maps.get(TOKEN))) {
                auth = createAuth("admin", "admin", UserType.ADMIN, maps.get(USER_ID));
            }else if (WATCH_TOKEN.equals(maps.get(TOKEN))) {
                auth = createAuth("netschool", "netschool", UserType.NETSCHOOL, maps.get(USER_ID));
            } else {
                return;
            }
        }
        synchronized (this) {
            //解析用户关系并绑定到对应的通道中
            validate = resolveUserInfo(auth, ctx);
        }
        if (validate) {
            //验权和用户信息更新成功后,处理请求,用于ws握手消息返回
            handleHttpRequest(ctx, (FullHttpRequest) msg);
            //处理业务中的打开操作,调用EndpointServiceImpl实现  
            endpointService.doOnOpen(ctx, fhr);
        } else {
            log.error("auth fail! --- " + fhr.headers().get("Auth"));
        }

    } else if (msg instanceof WebSocketFrame) {
        //WebSocket接入
        handleWebSocketFrame(ctx, (WebSocketFrame) msg);
    }
}
```

WebSocket接入后是正常主要处理的方法

```java
private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {
    //判断是否关闭链路指令
    if (frame instanceof CloseWebSocketFrame) {
        log.info("客户端正常退出");
        handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
        return;
    }
    //判断是否是Ping消息
    if (frame instanceof PingWebSocketFrame) {
        ctx.channel().write(new PongWebSocketFrame().retain());
        return;
    }

    //判断是否是pong的消息
    if (frame instanceof PongWebSocketFrame) {
        log.info(String.format("%s received pong %s", ctx.channel(), (PongWebSocketFrame) frame));
        return;
    }
    //处理二进制文件,实际并没有而精致二进制断点实现,所以没用
    if (frame instanceof BinaryWebSocketFrame) {
        endpointService.doOnBinary(ctx, (BinaryWebSocketFrame) frame);
        return;
    }
    //仅支持文本信息，不支持二进制消息
    if (!(frame instanceof TextWebSocketFrame)) {
        throw new UnsupportedOperationException(String.format("%s frame types not supported", frame.getClass().getName()));
    }
    //正常处理文本消息
    endpointService.doOnMessage(ctx, (TextWebSocketFrame) frame);
}
```

所有通过连接产生的业务都是由EndpointServiceImpl实际分发到各个断点处理完成,实际使用到的是如下三个方法.

```java
public interface EndpointService {
    /**
     * 查找并执行当前连接对应的onOpen端点方法
     *
     * @param ctx 当前消息上下文
     * @param req 完整的http连接请求
     */
    void doOnOpen(ChannelHandlerContext ctx, FullHttpRequest req);

    /**
     * 查找并执行当前连接对应的onClose端点方法
     *
     * @param ctx   当前消息上下文
     * @param frame channel close的相关参数
     */
    void doOnClose(ChannelHandlerContext ctx, CloseWebSocketFrame frame);

    /**
     * 查找并执行当前连接对应的onMessage端点方法
     *
     * @param ctx   当前消息上下文
     * @param frame 通道收到的文本消息
     */
    void doOnMessage(ChannelHandlerContext ctx, TextWebSocketFrame frame);
}
```

开启和关闭方法相似,代码如下,通过获取appid调用对应断点中的方法

```java
public void doOnClose(ChannelHandlerContext ctx, CloseWebSocketFrame frame) {
    Session session = new Session(ctx);
    String appId = session.getAppKey();
    Method onClose = endpointMapper.getOnClose(appId);
    Object instance = endpointMapper.getEndpointInstance(appId);
    try {
        if (null == instance || null == onClose) {
            instance = endpointMapper.getDefaultEndpointInstance();
            onClose = endpointMapper.getOnClose();
        }
        onClose.invoke(instance, session, frame);
    } catch (.. e) {
        e.printStackTrace();
    } 
}
```

而doOnMessage方法主要处理command和message方法.首先获取对应的command端点,如果获取失败则默认用default端点处理.

## 具体业务实现

### 开启连接

以云课堂为例,ZTKT4Endpoints,开始和通道建立连接

```java
public void onOpen(Session session, HttpHeaders headers, Map<String, String> paramMap) {
    // 获取头中的身份信息，判断身份
    // 若是老师则创建房间，若是成员则加入房间
    ConnectInfoDTO infoDTO = ConnectInfoDTO.ofStudent(session.getUserId(), session.getUserInfo().getRoomId());
    //在开始解析用户的时候已经,将用户绑定到对应的通道中了,所以这一步能获取到
    Set<String> groups = session.getUserInfo().getGroups() != null ? session.getUserInfo().getGroups() :
            Sets.newHashSet();
    if (StringUtil.isNotEmptyAndNotZero(session.getUserType())) {
        if (UserType.OWNER == session.getUserType() || UserType.ADMIN == session.getUserType()) {
            //老师创建房间
            String roomId = session.getRoomId();
            CreateRoomRequest request = new CreateRoomRequest();
            request.setRoomId(roomId)
                    .setBlackList(new HashSet<>())
                    .setMembers(new HashSet<>())
                    .setOwnerId(session.getUserId())
                    .setWhitelist(new HashSet<>())
                    .setGroups(groups)
                    .setNotificationSwitch(DEFAULT_NOTIFICATION_SWITCH);
            roomService.createRoom(new Room().convertRequestToRoom(request), groups, session.channel());
            log.warn("user:{} create room roomId:{} success", session.getUserId(), session.getRoomId());
            //把业务者加入到业务者房间 老师也加入到业务者房间
            roomService.joinRoom(String.format(Constants.ADMIN_ROOMID, session.getAppKey(), session.getAppKey()),
                    session.getUserId(), groups, session.channel());
            log.info("create room success");
            // 给业务服务,推送消息到业务服务
            sendToServer(OldCommandDTO.ofOnlineCmd(JsonUtil.toJSON(infoDTO), session), session);
            //给所有学生通知老师上线
            OldCommandDTO hostOnlineCmd = OldCommandDTO.ofHostOnlineCmd(JsonUtil.toJSON(infoDTO), session);
            //广播
            broadCast(session, JsonUtil.toJSON(hostOnlineCmd));
            //进去直推,给mq发送上线消息
            sendOnlineList(session);
        } else {
            //普通用户直接加入房间
            roomService.joinRoom(session.getRoomId(), session.getUserId(), session.getUserInfo().getGroups(),
                    session.channel());
            log.info("user:{} join room success", session.getUserId());
            // 上线是6 下线是7 组装OldCommandDTO
        }
        if (UserType.LINKTEACHER == session.getUserType() || UserType.OWNER == session.getUserType()){
            //添加到助教在线列表
            roomService.addLinkTeacher(session.getUserId(), session.getRoomId());
            //给所有助教推送消息
            sendLinkTeacherOnlineList(session);
        }
        roomService.addOnlineNotificationRoomSet(session.getRoomId());
    }
}
```

房主(老师)上线的时候,需要单播发送给业务服务,业务服务处理老师点到相关信息,实际处理在MQReceiverImpl#process 方法中处理

```java
/**
 * 单播到业务服务
 *
 * @param oldCommandDTO 旧通道命令
 * @param session       会话
 */
private void sendToServer(OldCommandDTO oldCommandDTO, Session session) {
    String message = JsonUtil.toJSON(oldCommandDTO);
    String roomId = String.format(Constants.ADMIN_ROOMID, session.getAppKey(), session.getAppKey());
    String toId;
    try {
        //获取所有连接的业务服务地址,当前时间取余后获取id
        toId = getBalanceBusinessClient(roomId);
    } catch (ChannelNotFoundException e) {
        log.info("推送至业务服务失败");
        return;
    }
    //组装出口信息
    InMessage inMessage = InMessage.of(oldCommandDTO, message);
    inMessage.setTo(toId);
    inMessage.setCmd(CMD.UNICAST);
    OutMessage outMessage = OutMessage.of(inMessage, session);
    outMessage.setRoomId(String.format(Constants.ADMIN_ROOMID, session.getAppKey(), session.getAppKey()));
    //实际将消息投递到交换机ykt.channel.exchange中,该交换机为扇出交换机
    indirectSender.unicast(outMessage);
    log.info("推送至业务服务");
}
```

实际mq处理,获取到对应的channel然后发送消息

```java
public void process(OutMessage outMessage) {
    	//获取发送对象,房间及消息文本
        String toId = outMessage.getTo() != null ? outMessage.getTo() : "";
        Set<String> exceptUsers = outMessage.getExceptUsers() != null ? outMessage.getExceptUsers() :
                Sets.newHashSet();
        Set<String> includeUsers = outMessage.getIncludeUsers() != null ? outMessage.getIncludeUsers() :
                Sets.newHashSet();
        String userId = outMessage.getUserId();
        String message = outMessage.getMessage();
        String roomId = outMessage.getRoomId();
        exceptUsers.add(userId);
        includeUsers.remove(userId);
        int cmd = outMessage.getCmd();
        switch (cmd) {
            case CMD.UNICAST:
                //避免多条连接存在的情况,调用通道发送
                unicast(roomId, toId, message);
                break;
            case CMD.BROADCAST:
                //广播需要排除一些人,比如发送者
                broadcast(roomId, userId, message, exceptUsers);
                break;
            case CMD.BROADCAST_INCLUDE:
                //对特定对象发送消息
                broadcastInclude(roomId, message, includeUsers);
                break;
            default:
                log.error("unknown command {}", cmd);
                break;
        }
   
}
```

给房间中的在线成员广播消息

```java
    // 此处直接使用默认的广播
@OnCommand(CMD.OldCMD.BROADCAST)
public void broadCast(Session session, String message) {
    //组装消息体,获取房间信息
    OldCommandDTO oldCommandDTO = JsonUtil.parseObject(message, OldCommandDTO.class);
    InMessage inMessage = InMessage.of(oldCommandDTO, message);
    OutMessage outMessage = OutMessage.of(inMessage, session);
    outMessage.setRoomId(String.format(Constants.ADMIN_ROOMID, session.getAppKey(), oldCommandDTO.getId()));
    Room room = roomRedis.findRoom(outMessage.getRoomId());
    Set<String> includeUsers = roomRedis.getRoomGroupMembers(outMessage.getRoomId(), oldCommandDTO.getTags());
    //如果广播来自业务者则在广播中排除房主（老师）
        //来自业务者 业务者需要排除不广播老师
        if (session.getUserInfo().getUserType() == UserType.ADMIN) {
            outMessage.setExceptUsers(Sets.newHashSet(room.getOwnerId()));
            outMessage.setCmd(CMD.BROADCAST);
            //此处广播都是通过投递mq中转处理后实现
            indirectSender.broadcast(outMessage);
        } else {
            //来自平板
            if (includeUsers.isEmpty()) {
                log.warn("小组用户为空");
            }
            outMessage.setIncludeUsers(includeUsers);
            outMessage.setCmd(CMD.BROADCAST_INCLUDE);
            indirectSender.broadcast(outMessage);
        }
    }
}
```

### 关闭连接

当通道不活跃时,会清除连接缓存,并调用端点的onclose方法

```java
public void channelInactive(ChannelHandlerContext ctx) throws Exception {
    //判断是否是因为空闲而关闭的
    boolean closedByIdle = ChannelSessionManager.isClosedByIdle(ctx.channel());
    //判断是否有身份信息
    if (ChannelSessionManager.hasSessionAttribute(ctx.channel())) {
        log.info("channelInactive,clean cache, is closed by Idle:{}", closedByIdle);
        //清除相关缓存并调用端点的onclose方法
        cleanChannel(ctx, closedByIdle);
    } else {
        log.warn("it is not protocol channel:[{}], is closed by Idle:{}", ctx.channel().remoteAddress(),
                closedByIdle);
    }
    super.channelInactive(ctx);
}
```

清理channel

```java
private void cleanChannel(ChannelHandlerContext ctx, boolean closedByIdle) {
    //通过通道获取用户信息(房间,应用,用户id等)
    Channel channel = ctx.channel();
    UserInfo userInfo = ChannelSessionManager.getChannelSession(channel);
    String roomId = userInfo.getRoomId();
    String userId = userInfo.getUserId();
    String appKey = userInfo.getAppKey();
    String channelRoomId = userInfo.getChannelRoomId();
    //获取当前用户连接信息
    UserSession userSession = userSessionService.find(userInfo.getUserId());
    String channelIdText = userSession != null ? userSession.getChannelId() : null;
    //不是最后一条连接 则不进行doOnClose操作
    if (userSession != null && channelIdText.equals(channel.id().asShortText())) {
        //当最后一条连接关闭时,清除缓存在线人数,房间在线人数,连接用户信息,doOnClose
        userSessionService.delete(userId);
        entiretyRecord.updateEntiretyRecordOffline(channelRoomId, userId);
        roomRecord.updateRoomRecordOffline(channelRoomId, userId);
        endpointService.doOnClose(ctx, null);
    }
    //处理用户离开房间记录 todo 待整理
    final short recordType = closedByIdle ? UserRecordType.PASSIVE_LEAVE_ROOM : UserRecordType.LEAVE_ROOM;
    final long connectedTime = System.currentTimeMillis() - ChannelSessionManager.getChannelConnectedTime(channel);
    String channelId = channel.id().asShortText();
    InetSocketAddress inetSocketAddress = (InetSocketAddress) ctx.channel().remoteAddress();
    String clientIP = inetSocketAddress.getAddress().getHostAddress();
    int port = inetSocketAddress.getPort();
    //今日用户信息记录
    userRecord.addUserRecord(userInfo, recordType, channelId, clientIP, port, connectedTime);
    //{ip|port|appkey|roomId|userId|channelId|userRecordType|createTime|connectedTime}
    log.trace("big-data-user-record:{}|{}|{}|{}|{}|{}|{}|{}|{}", clientIP, port, appKey,
            roomId, userId, channelId, recordType, System.currentTimeMillis(), connectedTime);
    //清理本地缓存
    channelHolder.cleanChannel(roomId, userInfo.getUserId(), ctx.channel().id());
}
```

端点onClose实际操作还是以ztkt4为例

```java
public void onClose(Session session, CloseWebSocketFrame frame) {
    roomService.leaveRoom(session.getRoomId(), session.getUserId(), session.getUserInfo().getGroups(),
            session.channel());
    // 上线是6 下线是7 组装OldCommandDTO
    ConnectInfoDTO infoDTO;
    if (UserType.MEMBER == session.getUserType()) {
        infoDTO = ConnectInfoDTO.ofStudent(session.getUserId(), session.getUserInfo().getRoomId());
    } else {
        infoDTO = ConnectInfoDTO.ofTeacher(session.getUserId(), session.getUserInfo().getRoomId());
    }
    sendToServer(OldCommandDTO.ofOfflineCmd(JsonUtil.toJSON(infoDTO), session), session);
    roomService.addOnlineNotificationRoomSet(session.getRoomId());
    sendOfflineNotifacation(session.getRoomId(), session.getUserId());
    // 如果下线的是房主，广播cmd为10的房主下线
    if (UserType.OWNER == session.getUserInfo().getUserType()) {
        OldCommandDTO hostOfflineCmd = OldCommandDTO.ofHostOfflineCmd(JsonUtil.toJSON(infoDTO), session);
        broadCast(session, JsonUtil.toJSON(hostOfflineCmd));
        //从业务者房间剔除
        roomService.leaveRoom(String.format(Constants.ADMIN_ROOMID, session.getAppKey(), session.getAppKey()),
                session.getUserId(), session.getUserInfo().getGroups(), session.channel());
    }
    if (UserType.LINKTEACHER == session.getUserType() || UserType.OWNER == session.getUserType()){
        //移除助教在线列表
        roomService.deleteLinkTeacher(session.getUserId(), session.getRoomId());
        //给所有助教推送消息
        sendLinkTeacherOnlineList(session);
    }
    log.info("onClose" + session.getUserType());
}
```