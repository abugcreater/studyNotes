# 数据库故障恢复机制

## 问题

数据库系统运行过程中可能遇到的故障类型主要包括，Transaction Failure，Process Failure，System Failure以及Media Failure。其中Transaction Failure可能是主动回滚或者冲突后强制Abort；Process Failure指的是由于各种原因导致的进程退出，进程内存内容会丢失；System Failure来源于操作系统或硬件故障；而Media Failure则是存储介质的不可恢复损坏。数据库系统需要正确合理的处理这些故障，从而保证系统的正确性。为此需要提供两个特性：

- **Durability of Updates：已经Commit的事务的修改，故障恢复后仍然存在；**
- **Failure Atomic：失败事务的所有修改都不可见**。

故障恢复的问题描述为：**即使在出现故障的情况下，数据库依然能够通过提供Durability及Atomic特性，保证恢复后的数据库状态正确。**

## Shadow Paging

System R的磁盘数据采用Page为最小的组织单位，一个File由多个Page组成，并通过称为Direcotry的元数据进行索引，每个Directory项纪录了当前文件的Page Table，指向其包含的所有Page。采用Shadow Paging的文件称为Shadow File，如下图中的File B所示，这种文件会包含两个Directory项，Current及Shadow:

![shadow paging](http://catkang.github.io/assets/img/crash_recovery/shadow_paging.png)



事务对文件修改时会获得新的page,并加入Current的Page Table,所有的操作只发生在Current Directory;Commit时,current指向的page刷盘,通过原子操作将该page合并到shadow directory中,之后再返回commit成功.事务回滚时只需要简单丢弃current指向的page;如果过程发生故障,只需要恢复Shadow Directory,相当于对所有未提交事务的回滚操作.

- Durability of Updates：事务完成Commit后，所有修改的Page已经落盘，合并到Shadow后，其所有的修改可以在故障后恢复出来。
- Failure Atomic：回滚的事务由于没有Commit，从未影响Shadow Directory，因此其所有修改不可见。

**缺点**:不支持page内并发,一个commit会提交page中所有事务;需要不断修改page物理位置,破坏局部性;Commit过程在关键路径上修改Shadow Directory的开销可能很大，同时这个操作还必须保证原子；增加了垃圾回收的负担,包括对失败事务的回收.

## WAL

每次修改数据内容钱先顺序写对应的Log,同时**为了保证恢复时可以从Log中看到最新的数据库状态，要求Log先于数据内容落盘，也就是常说的Write Ahead Log，WAL**。事务完后commit前在log记录commit标记,还需要关注标记和数据内容的落盘顺序.根据Log中记录的内容可以分为三类：Undo-Only，Redo-Only，Redo-Undo。

**Undo-Only Logging**

Undo-Only Logging的Log记录可以表示未<T, X, v>，事务T修改了X的值，X的旧值是v.事务提交的**落盘顺序为Log记录->Data->Commit标记**.恢复时可以根据commit标记判断事务状态,修改未提交事务数据.
Undo-Only对Durability及Atomic的保证：

- Durability of Updates：Data强制刷盘保证，已经Commit的事务由于其所有Data都已经在Commit标记之前落盘，因此会一直存在；
- Failure Atomic：Undo Log内容保证，失败事务的已刷盘的修改会在恢复阶段通过Undo日志回滚，不再可见。

**缺点:**Undo-Only依然有不能Page内并发的问题，如果两个事务的修改落到一个Page中，一个事务提交前需要的强制Flush操作，会导致同Page所有事务的Data落盘，可能会早于对应的Log项从而损害WAL。同时，也会导致关键路径上过于频繁的磁盘随机访问。



**Redo-Only Logging**

Redo-Only的Log中记录的是修改后的新值,**落盘顺序为Log记录->Commit标记->Data**

- Durability of Updates：Redo Log内容保证，已提交事务的未刷盘的修改，利用Redo Log中的内容重放，之后可见；
- Failure Atomic：阻止Commit前Data落盘保证，失败事务的修改不会出现在磁盘上，自然不可见。

**缺点:**Redo-Only同样有不能Page内并发的问题，Page中的多个不同事务，只要有一个未提交就不能刷盘，这些数据全部都需要维护在内存中，造成较大的内存压力



**Redo-Undo Logging**

因此Redo-Undo采用同时记录新值和旧值的方式，来**消除Commit和Data之间刷盘顺序的限制**。

- Durability of Updates：Redo 内容保证，已提交事务的未刷盘的修改，利用Redo Log中的内容重放，之后可见；
- Failure Atomic：Undo内容保证，失败事务的已刷盘的修改会在恢复阶段通过Undo日志回滚，不再可见。

同Page的不同事务提交就变得非常简单。同时可以将连续的数据攒着进行批量的刷盘已利用磁盘较高的顺序写性能.



## Force and Steal

**Redo和Undo内容分别可以保证Durability和Atomic两个特性，其中一种信息的缺失需要用严格的刷盘顺序来弥补**。刷盘顺序包含两个维度:

- **Force or No-Force**：Commit时是否需要强制刷盘，采用Force的方式由于所有的已提交事务的数据一定已经存在于磁盘，自然而然地保证了Durability；
- **No-Steal or Steal**，Commit前数据是否可以提前刷盘，采用No-Steal的方式由于保证事务提交前修改不会出现在磁盘上，自然而然地保证了Atomic。

**实现Durability可以通过记录Redo信息或要求Force刷盘顺序，实现Atomic需要记录Undo信息或要求No-Steal刷盘顺序**，组合得到如下四种模式，如下图所示：

![quadrant](http://catkang.github.io/assets/img/crash_recovery/quadrant.png)

## ARIES，一统江湖

ARIES本质是一种Redo-Undo的WAL实现.

 **Normal过程(事务commit)：**修改数据前先追加Log记录,记录同事包括redo和undo信息,每个记录产生一个标记,其在日志中位置的递增LSN（Log Sequence Number）;数据页中记录最后修改的LSN,用来判断page中内容的新旧程度,实现幂等.恢复时通过日志中内容恢复现状.定期生成Checkpoint,减少日志量.Checkpoint中除了当前的日志LSN之外，还需要记录当前活跃事务的最新LSN，以及所有脏页，供恢复时决定重放Redo的开始位置.注意Checkpoint记录的活跃事务及Dirty Page信息并不一定准确，因此需要Recovery阶段通过Log内容进行修正。

**Recover过程(数据库恢复)：**故障恢复包含三个阶段：Analysis，Redo和Undo。Analysis阶段的任务主要是利用Checkpoint及Log中的信息确认后续Redo和Undo阶段的操作范围，通过Log修正Checkpoint中记录的Dirty Page集合信息，并用其中涉及最小的LSN位置作为下一步Redo的开始位置RedoLSN。同时修正Checkpoint中记录的活跃事务集合（未提交事务），作为Undo过程的回滚对象；Redo阶段从Analysis获得的RedoLSN出发，重放所有的Log中的Redo内容，注意这里也包含了未Commit事务；最后Undo阶段对所有未提交事务利用Undo信息进行回滚，通过Log的PrevLSN可以顺序找到事务所有需要回滚的修改

ARIES有两个主要的设计目标：

- **Feature：提供丰富灵活的实现事务的接口：**包括提供灵活的存储方式、提供细粒度的锁、支持基于Savepoint的事务部分回滚、通过Logical Undo以获得更高的并发、通过Page-Oriented Redo实现简单的可并发的Recovery过程。
- **Performance：充分利用内存和磁盘介质特性，获得极致的性能：**采用No-Force避免大量同步的磁盘随机写、采用Steal及时重用宝贵的内存资源、基于Page来简化恢复和缓存管理。

## NVM带来的机遇与挑战

相对于传统磁盘的HDD及SSD，NVM最大的优势在于：

- 接近内存的高性能
- 顺序访问和随机访问差距不大
- 按字节寻址而不是Block

在这种情况下，再来看ARIES的实现：

- No-force and Steal：同时维护Redo， Undo和数据造成的三倍写放大，来换取磁盘顺序写的性能，但在NVM上这种取舍变得很不划算；
- Pages：为了迁就磁盘基于Block的访问接口，采用Page的存储管理方式，而内存本身是按字节寻址的，因此，这种适配也带来很大的复杂度。在同样按字节寻址的NVM上可以消除。

以下是尝试为NVM量身定制更合理的故障恢复机制,其中两种比较有代表性的研究成果.



### MARS

MARS取消了Undo Log，保留的Redo Log也不同于传统的Append-Only，而是可以随机访问的。如下图所示，每个事务会占有一个唯一的TID，对应的Metadata中记录了Log和Data的位置。

![mars](http://catkang.github.io/assets/img/crash_recovery/mars.png)

所有的数据修改都在对应的Redo Log中进行，不影响真实数据，由于没有Undo Log，需要采用No-Steal的方式，阻止Commit前的数据写回；Commit时会先设置事务状态为COMMITTED，之后利用NVM的内部带宽将Redo中的所有内容并发拷贝回Metadata中记录的数据位置。如果在COMMITED标记设置后发生故障，恢复时可以根据Redo Log中的内容重放。其**本质是一种Redo加No-Steal的实现方式**：

- Durability of Updates： Redo实现，故障后重放Redo；
- Failure Atomic：未Commit事务的修改只存在于Redo Log，重启后会被直接丢弃。

### WBL

WBL去掉了传统的Append Only的Redo和Undo日志，但仍然需要保留Undo信息用来回滚未提交事务。事务Commit前需要将其所有的修改强制刷盘，之后在Log中记录Commit标记，也就是这里说的Write Behind Log.恢复过程中通过分析Commit标记将为提交的事务通过Undo信息回滚。可以看出WBL算法本身非常简单，在这个基础上，WBL做了如下优化：

- Group Commit：周期性的检查内存中的修改，同样在所有修改刷盘之后再写Log，Log项中记录Commit并落盘的最新事务TimeStamp cp，保证早于cp的所有事务修改都已经落盘；同时记录当前分配出去的最大TimeStamp cd；也就是说此时所有有修改但未提交的事务Timestamp都落在cp和cd之间。Reovery的时候只需对这部分数据进行回滚；
- 针对多版本数据库，多版本信息已经起到了undo的作用，因此不需要再额外记录undo信息；
- 延迟回滚：Recovery后不急于对未提交事务进行回滚，而是直接提供服务，一组(cp, cd)称为一个gap，每一次故障恢复都可能引入新的gap，通过对比事务Timestamp和gap集合，来判断数据的可见性，需要依靠后台垃圾回收线程真正的进行回滚和对gap的清理，如下图所示；

![image-20190116010114230](http://catkang.github.io/assets/img/crash_recovery/wbl.png)

- 可以看出，WBL本质并没有什么新颖，是一个**Force加Undo的实现方式**，其正确性保证如下：
- Durability of Updates：Commit事务的数据刷盘后才进行Commit，因此Commit事务的数据一定在Recovery后存在
- Failure Atomic：通过记录的Undo信息或多版本时的历史版本信息，在Recovery后依靠后台垃圾回收线程进行回滚。

## 总结


![classify](http://catkang.github.io/assets/img/crash_recovery/classify.png)

- Shadow Paging可以看做是采用了Force加No-Steal的方式，没有Log信息，在Commit时，通过原子的修改Directory元信息完成数据的持久化更新，但由于其对Page内并发的限制等问题，没有成为主流；
- Logging的实现方式增加了Redo或Undo日志，记录恢复需要的信息，从而放松Force或No-Steal机制对刷盘顺序的限制，从而尽量用磁盘顺序写代替随机写获得较好的性能。ARIES算法是在这一方向上的集大成者，其对上层应用提供了丰富灵活的接口，采用了No-Force加Steal机制，将传统磁盘上的性能发挥到极致，从而成为传统磁盘数据故障恢复问题的标准解决方案；
- 随着NVM设备的逐步出现，其接近内存的性能、同样优异的顺序访问和随机访问表现，以及基于字节的寻址方式，促使人们开始重新审视数据库故障恢复的实现。其核心思路在于充分利用NVM硬件特性，减少Log机制导致的写放大以及设计较复杂的问题；
- MARS作为其中的佼佼者之一，在NVM上维护可以随机访问的Redo日志，同时采用Force加Steal的缓存策略，充分利用NVM优异的随机写性能和内部带宽。
- WBL从另一个方向进行改造，保留Undo信息，采用No-Force加No-Steal的缓存策略，并通过Group Commit及延迟回滚等优化，减少日志信息，缩短恢复时间。









参考:[数据库故障恢复机制的前世今生](http://catkang.github.io/2019/01/16/crash-recovery.html)