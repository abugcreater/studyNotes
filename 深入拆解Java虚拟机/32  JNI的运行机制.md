# 32 | JNI的运行机制

### native 方法的链接

在调用 native 方法前，Java 虚拟机需要将该 native 方法链接至对应的 C 函数上。

链接方式主要有两种。第一种是让 Java 虚拟机自动查找符合默认命名规范的 C 函数，并且链接起来。

采用`javac -h`命令生成包含符合命名规范的 C 函数的头文件。

```
//示例代码
package org.example;
 
public class Foo {
  public static native void foo();
  public native void bar(int i, long j);
  public native void bar(String s, Object o);
}
//执行命令
javac -h . org/example/Foo.java
//生成的C函数头文件
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class org_example_Foo */
 
#ifndef _Included_org_example_Foo
#define _Included_org_example_Foo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     org_example_Foo
 * Method:    foo
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_org_example_Foo_foo
  (JNIEnv *, jclass);
 
/*
 * Class:     org_example_Foo
 * Method:    bar
 * Signature: (IJ)V
 */
JNIEXPORT void JNICALL Java_org_example_Foo_bar__IJ
  (JNIEnv *, jobject, jint, jlong);
 
/*
 * Class:     org_example_Foo
 * Method:    bar
 * Signature: (Ljava/lang/String;Ljava/lang/Object;)V
 */
JNIEXPORT void JNICALL Java_org_example_Foo_bar__Ljava_lang_String_2Ljava_lang_Object_2
  (JNIEnv *, jobject, jstring, jobject);
 
#ifdef __cplusplus
}
#endif
#endif
```

命名规范:native 方法对应的 C 函数都需要以`Java_`为前缀,后面跟完整包名,方法名.原本方法名中的`_`符号，则需要转换为`_1`

当某个类出现重载的 native 方法时，Java 虚拟机还会将参数类型纳入自动链接对象的考虑范围之中。具体的做法便是在前面 C 函数名的基础上，追加`__`以及方法描述符作为后缀。

第二种是在 C 代码中主动链接。

这种链接方式对 C 函数名没有要求。通常我们会使用一个名为`registerNatives`的 native 方法，并按照第一种链接方式定义所能自动链接的 C 函数。在该 C 函数中，我们将手动链接该类的其他 native 方法。

```
// 示例 注：Object 类的 registerNatives 方法的实现位于 java.base 模块里的 C 代码中
static JNINativeMethod methods[] = {
    {"hashCode",    "()I",                    (void *)&JVM_IHashCode},
    {"wait",        "(J)V",                   (void *)&JVM_MonitorWait},
    {"notify",      "()V",                    (void *)&JVM_MonitorNotify},
    {"notifyAll",   "()V",                    (void *)&JVM_MonitorNotifyAll},
    {"clone",       "()Ljava/lang/Object;",   (void *)&JVM_Clone},
};
 
JNIEXPORT void JNICALL
Java_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)
{
    (*env)->RegisterNatives(env, cls,
                            methods, sizeof(methods)/sizeof(methods[0]));
}
```

当使用第二种方式进行链接时，我们需要在其他 native 方法被调用之前完成链接工作。因此，我们往往会在类的初始化方法里调用该`registerNatives`方法。

### JNI 的 API

在 C 代码中，我们也可以使用 Java 的语言特性，如 instanceof 测试等。这些功能都是通过特殊的 JNI 函数（[JNI Functions](https://docs.oracle.com/en/java/javase/11/docs/specs/jni/functions.html)）来实现的。

Java 虚拟机会将所有 JNI 函数的函数指针聚合到一个名为`JNIEnv`的线程私有的数据结构之中。

设计目的:给JNI提供单独命名空间;允许Java虚拟机通过更改函数指针替换JNI函数的具体实现.

JNI 会将 Java 层面的基本类型以及引用类型映射为另一套可供 C 代码使用的数据结构。

![image-20211229172639593](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211229172639593.png)

Java中静态JNI方法,C中接受参数为`JNIEnv`指针和`jclass`参数(该native方法的类).实例方法接受`JNIEnv`指针和`jobject`指代该 native 方法的调用者.

关于JNI异常情况:当调用 JNI 函数时，Java 虚拟机便已生成异常实例，并缓存在内存中的某个位置。与 Java 编程不一样的是，它并不会显式地跳转至异常处理器或者调用者中，而是继续执行接下来的 C 代码。

当从可能触发异常的 JNI 函数返回时，我们需要通过 JNI 函数`ExceptionOccurred`检查是否发生了异常，并且作出相应的处理。如果无须抛出该异常，那么我们需要通过 JNI 函数`ExceptionClear`显式地清空已缓存的异常。

### 局部引用与全局引用

 JNI 的局部引用（Local Reference）和全局引用（Global Reference）该机制旨在告知垃圾回收算法,不要回收Native中的Java对象.

事实上，无论是传入的引用类型参数，还是通过 JNI 函数（除`NewGlobalRef`及`NewWeakGlobalRef`之外）返回的引用类型对象，都属于局部引用。本地方法返回后局部变量失效,除非借助JNI 函数`NewGlobalRef`,转变为全局引用,保证对象不会被回收.

HotSpot 虚拟机是通过句柄（handle）来完成当垃圾回收器移动对象位置时还保值有效引用.

局部引用所对应的句柄有两种存储方式，一是在本地方法栈帧中，主要用于存放 C 函数所接收的来自 Java 层面的引用类型参数；另一种则是线程私有的句柄块，主要用于存放 C 函数运行过程中创建的局部引用。

当从 C 函数返回至 Java 方法时，本地方法栈帧中的句柄将会被自动清除。而线程私有句柄块则需要由 Java 虚拟机显式清理。

进入 C 函数时对引用类型参数的句柄化，和调整参数位置（C 调用和 Java 调用传参的方式不一样），以及从 C 函数返回时清理线程私有句柄块，共同造就了 JNI 调用的额外性能开销（具体可参考该 stackoverflow 上的[回答](https://stackoverflow.com/questions/24746776/what-does-a-jvm-have-to-do-when-calling-a-native-method/24747484#24747484)）。