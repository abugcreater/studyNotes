# 11 | 垃圾回收

### 引用计数法与可达性分析

引用计数法(reference counting):为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。

当出现循环引用时导致对象永远无法被回收.

可达性分析算法:将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

GC Roots : Java 方法栈桢中的局部变量;已加载类的静态变量;JNI handles;已启动且未停止的 Java 线程

### Stop-the-world 以及安全点

Stop-the-world:停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间(GC pause).STP通过安全点机制实现,当所有线程都到安全点时,才执行STP操作.

Java线程的几种状态:

1. 执行JNI本地代码(入口检测安全点)
2. 解释执行字节码(有安全点请求时,执行一条安全帽执行一次检测)
3. 执行即时编译器生成的机器码(生成代码的方法出口及非计数循环回边插入安全监测点)
4. 线程阻塞(安全点)

### 垃圾回收的三种方式

标记清除(sweep):死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。

该方法会造成大量内存碎片,分配效率较低

压缩(compact):即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。

复制(copy):即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。

该方法能解决内存碎片,但是会造成堆空间使用效率降低.



### Java 虚拟机的堆划分

Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区.

va 虚拟机采取的是一种动态分配的策略（对应 Java 虚拟机参数 -`XX:+UsePSAdaptiveSurvivorSizePolicy`），根据生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例.

为了防止分配对象时,不同的对象分配到同一个内存中,所以分配对象操作需要同步进行.JVM的解决方法是预申请(TLAB:Thread Local Allocation Buffer 默认开启,对应的参数`-XX:+UseTLAB` ).

TLAB实现,每个线程预申请一块内存,保存开始与结束指针.当使用`new`指令时,通过指针加法(bump the point),计算空余内存是否小于结尾指针,如果小于则分配成功.不够则在申请,一直不够则会触发`Minor GC`.

GC ROOT中保存老年代对新生代的引用,为了避免全堆搜索,JVM使用卡表标记.

### 卡表

该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。

只对脏卡进行扫描,扫描时清除标记,对象复制时再更新标记.

如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。

