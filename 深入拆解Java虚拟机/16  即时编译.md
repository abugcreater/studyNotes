# 16 | 即时编译

### 分层编译模式

HotSpot 虚拟机包含多个即时编译器 C1、C2 和 Graal。

C1编译速度较快 ,对于执行时间短或者有启动性能有要求的则使用C1,对应参数 `-client`

C2编译速度较慢,对于执行时间长,或者对峰值性能有要求的使用C2,对应参数`-server`

C1,C2均是用C++实现的即时编译器.而Graal则是用Java实现的编译器.他可以实行预编译.

扩展[AOT和JIT以及混合编译的区别、优劣](https://www.cnblogs.com/linghu-java/p/10577515.html).

[Introduction to Graal](https://zhengyudi.github.io/2018/03/20/graal-intro/)

在JDK7时引入了分层编译(参数 -XX:+TieredCompilation)

分层编译将JVM执行状态分为了5个层次.

0. interpreter解释执行
1. C1编译,无profiling
2. C1编译,仅方法及循环back-edge执行次数的profiling
3. C1编译,所有profiling(包括回边,branch:分支跳转,receiver type:方法调用或类检测)
4. C2编译

profiling表示:程序执行过程中，收集能够反映程序执行状态的数据。这里所收集的数据我们称之为程序的 profile.

其中 1 和 4 为最终状态.执行效率 4 >> 1 > 2 >> 3 (其中>> 约等于30% ) 

![image-20211213154004486](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211213154004486.png)

1. 一般情况下由C1编译成 3 状态,然后由C2编译成4.
2. 如果编译对象非常简单，虚拟机认为通过C1编译或通过C2编译并无区别，便会直接由C1编译且不插入profiling代码 1.
3. 如果C1繁忙时,直接由C2编译成 4.
4. 在C2忙碌的情况下，方法则会先由C1编译并保持较少的profiling（level 2），以获取较高的执行效率.

### 即时编译的触发

Java虚拟机根据方法的调用次数以及循环回边的执行次数来触发即时编译。循环回边是一个控制流图中的概念，程序中可以简单理解为往回跳转的指令，比如下面这段代码：

```java
//方法
public void nlp(Object obj) {
  int sum = 0;
  for (int i = 0; i < 200; i++) {
    sum += i;
  }
}
//对应的字节码
public void nlp(java.lang.Object);
    Code:
       0: iconst_0
       1: istore_1
       2: iconst_0
       3: istore_2
       4: iload_2
       5: sipush        200
       8: if_icmpge     21
      11: iload_1
      12: iload_2
      13: iadd
      14: istore_1
      15: iinc          2, 1
      18: goto          4
      21: return
```

循环体的头部和尾部分别为偏移量为11的字节码和偏移量为15的字节码.循环尾部到循环头部的控制流边就是真正意义上的循环回边。C1 将在这个位置插入增加循环回边计数器的代码。

不分层时使用` -XX:CompileThreshold`控制编译,C1默认为1500,C2默认为10000.

分层编译时使用动态调整,调整规则如下

```
系数的计算方法为：
s = queue_size_X / (TierXLoadFeedback * compiler_count_X) + 1
 
其中 X 是执行层次，可取 3 或者 4；
queue_size_X 是执行层次为 X 的待编译方法的数目；
TierXLoadFeedback 是预设好的参数，其中 Tier3LoadFeedback 为 5，Tier4LoadFeedback 为 3；
compiler_count_X 是层次 X 的编译线程数目。
```

64位的Java虚拟机中编译线程数目,可以通过 -XX:+CICompilerCount=N 强制设定.C1:C2=1:2每个编译器最少有一条线程.

```
对于四核及以上的机器，总的编译线程的数目为：
n = log2(N) * log2(log2(N)) * 3 / 2
其中 N 为 CPU 核心数目。
```

```
当方法调用次数大于由参数 -XX:TierXInvocationThreshold 指定的阈值乘以系数，或者当方法调用次数大于由参数 -XX:TierXMINInvocationThreshold 指定的阈值乘以系数，并且方法调用次数和循环回边次数之和大于由参数 -XX:TierXCompileThreshold 指定的阈值乘以系数时，便会触发 X 层即时编译。
 
触发条件为：
i > TierXInvocationThreshold * s || (i > TierXMinInvocationThreshold * s  && i + b > TierXCompileThreshold * s)
```

### OSR 编译

Java 虚拟机还存在着另一种以循环为单位的即时编译，叫做 On-Stack-Replacement（OSR）编译。循环回边计数器便是用来触发这种类型的编译的。

OSR 实际上是一种技术，它指的是在程序执行过程中，动态地替换掉 Java 方法栈桢，从而使得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换。

启用分层编译的情况下，触发 OSR 编译的阈值则是由参数 `-XX:TierXBackEdgeThreshold` 指定的阈值乘以系数。

### Profiling

分支`profiling`记录跳转次数和不跳转次数.

类型` profile`记录非私有实例方法调用指令、强制类型转换 checkcast 指令、类型测试 instanceof 指令，和引用类型的数组存储 aastore 指令.

 profile 具体作用:C2 可以根据收集得到的数据进行猜测，假设接下来的执行同样会按照所收集的 profile 进行，从而作出比较激进的优化。

### 基于分支 profile 的优化

字节码

```
public static int foo(boolean f, int in) {
  int v;
  if (f) {
    v = in;
  } else {
    v = (int) Math.sin(in);
  }
 
  if (v == in) {
    return 0;
  } else {
    return (int) Math.cos(v);
  }
}
// 编译而成的字节码：
public static int foo(boolean, int);
  Code:
     0: iload_0
     1: ifeq          9
     4: iload_1
     5: istore_2
     6: goto          16
     9: iload_1
    10: i2d
    11: invokestatic  java/lang/Math.sin:(D)D
    14: d2i
    15: istore_2
    16: iload_2
    17: iload_1
    18: if_icmpne     23
    21: iconst_0
    22: ireturn
    23: iload_2
    24: i2d
    25: invokestatic java/lang/Math.cos:(D)D
    28: d2i
    29: ireturn
```

正常流程

![image-20211220194805529](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211220194805529.png)





通过优化剪枝后

![image-20211220194832365](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211220194832365.png)

根据条件跳转指令的分支 profile，即时编译器可以将从未执行过的分支剪掉，以避免编译这些很有可能不会用到的代码，从而节省编译时间以及部署代码所要消耗的内存空间。此外，“剪枝”将精简程序的数据流，从而触发更多的优化。

基于类型 profile 的优化同样也是作出假设，从而精简控制流以及数据流。这两者的核心都是假设。

对于分支 profile，即时编译器假设的是仅执行某一分支；对于类型 profile，即时编译器假设的是对象的动态类型仅为类型 profile 中的那几个。

### 去优化

假设失败时进行去优化，即从执行即时编译生成的机器码切换回解释执行。

在生成的机器码中，即时编译器将在假设失败的位置上插入一个陷阱（trap）。该陷阱实际上是一条 call 指令，调用至 Java 虚拟机里专门负责去优化的方法。与普通的 call 指令不一样的是，去优化方法将更改栈上的返回地址，并不再返回即时编译器生成的机器码中。(流程图上的?代表陷阱,如果进入该流程则进行去优化)