# 26 | 向量化

由于 X86_64 平台不支持内存间的直接移动，上面代码中的`dst[i] = src[i]`通常会被编译为两条内存访问指令：第一条指令把`src[i]`的值读取至寄存器中，而第二条指令则把寄存器中的值写入至`dst[i]`中.

```java
void foo(byte[] dst, byte[] src) {
  for (int i = 0; i < dst.length - 4; i += 4) {
    dst[i] = src[i];
    dst[i+1] = src[i+1];
    dst[i+2] = src[i+2];
    dst[i+3] = src[i+3];
  }
  ... // post-loop
}
//批量读取优化后
void foo(byte[] dst, byte[] src) {
  for (int i = 0; i < dst.length - 4; i += 4) {
    dst[i:i+3] = src[i:i+3];
  }
  ... // post-loop
}
```

### SIMD 指令

即时编译器将借助长度足够的 XMM 寄存器，来完成 int 数组与 long 数组的向量化读取和写入操作。 XMM 寄存器，是由 SSE（Streaming SIMD Extensions）指令集所引入的。它们一开始仅为 128 位。

![image-20211228102315095](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211228102315095.png)

SIMD(Single Instruction Multiple Data),通过单条指令操控多组数据的计算操作。这些指令我们称之为 SIMD 指令。

而 SIMD 指令`PADDB`、`PADDW`、`PADDD`以及`PADDQ`，将分别实现 byte 值、short 值、int 值或者 long 值的向量加法。

### 使用 SIMD 指令的 HotSpot Intrinsic

这主要是因为不同的 CPU 所支持的 SIMD 指令可能不同。一般来说，越新的 SIMD 指令，它所支持的寄存器长度越大，功能也越强。

HotSpot 虚拟机提供的替代方案是 Java 层面的 intrinsic 方法，这些 intrinsic 方法的语义要比单个 SIMD 指令复杂得多。在运行过程中，HotSpot 虚拟机将根据当前体系架构来决定是否将对该 intrinsic 方法的调用替换为另一高效的实现。如果不，则使用原本的 Java 实现。

不过，由于开发成本及维护成本较高，这种类型的 intrinsic 屈指可数，如用于复制数组的`System.arraycopy`和`Arrays.copyOf`，用于比较数组的`Arrays.equals`，以及 Java 9 新加入的`Arrays.compare`和`Arrays.mismatch`，以及字符串相关的一些方法`String.indexOf`、`StringLatin1.inflate`。

### 自动向量化

即时编译器的自动向量化将针对能够展开的计数循环，进行向量化优化。

自动向量化的条件:

1. 循环变量的增量应为 1，即能够遍历整个数组。
2. 循环变量不能为 long 类型，否则 C2 无法将循环识别为计数循环。
3. 循环迭代之间最好不要有数据依赖，例如出现类似于`a[i] = a[i-1]`的语句。当循环展开之后，循环体内存在数据依赖，那么 C2 无法进行自动向量化。
4. 循环体内不要有分支跳转。
5. 不要手工进行循环展开。如果 C2 无法自动展开，那么它也将无法进行自动向量化。

