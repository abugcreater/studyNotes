# 20 | 方法内联

方法内联:编译过程中遇到方法调用,将目标方法的方法体纳入编译范围中,并取代原方法调用的优化手段.

C2中方法内联在解析字节码时完成,当方法需要内联时,则解析目标方法的字节码.

>  复习一下：即时编译器首先解析字节码，并生成 IR 图，然后在该 IR 图上进行优化。优化是由一个个独立的优化阶段（optimization phase）串联起来的。每个优化阶段都会对 IR 图进行转换。最后即时编译器根据 IR 图的节点以及调度顺序生成机器码。

Graal独立的优化过程,寻找指代方法调用的IR节点,将之替换成目标方法的IR图.

实例讲解

```
方法内联的过程
public static boolean flag = true;
public static int value0 = 0;
public static int value1 = 1;
 
public static int foo(int value) {
    int result = bar(flag);
    if (result != 0) {
        return result;
    } else {
        return value;
    }
}
 
public static int bar(boolean flag) {
    return flag ? value0 : value1;
}
```

**foo方法内联前**

![image-20211223143021576](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223143021576.png)

IR图中节点5调用bar方法,当判断需要内联时解析bar方法字节码,并生成IR图.

**bar方法IR图**

![image-20211223143157590](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223143157590.png)

**foo方法IR图内联后**

![image-20211223143310841](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223143310841.png)

把bar方法对应的IR图纳入到foo方法编译中,替换Invoke节点为bar方法的IR图.

除此之外,编译器还需要做如下操作:

1. 被调用方法的传入参数节点，将被替换为调用者方法进行方法调用时所传入参数对应的节点。在我们的例子中，就是将 bar 方法 IR 图中的 1 号 P(0) 节点替换为 foo 方法 IR 图中的 3 号 LoadField 节点。
2. 在调用者方法的 IR 图中，所有指向原方法调用节点的数据依赖将重新指向被调用方法的返回节点。如果被调用方法存在多个返回节点，则生成一个 Phi 节点，将这些返回值聚合起来，并作为原方法调用节点的替换对象。
3. 如果被调用方法将抛出某种类型的异常，而调用者方法恰好有该异常类型的处理器，并且该异常处理器覆盖这一方法调用，那么即时编译器需要将被调用方法抛出异常的路径，与调用者方法的异常处理器相连接



如果将变量通过final修饰变为常量则,foo方法的IR图将变为下图

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223143803040.png" alt="image-20211223143803040" style="zoom:50%;" />

通过死代码消除优化后

![image-20211223143835838](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223143835838.png)

### 方法内联的条件

Java虚拟机中,内联编译生成的机器码会部署到Code Cache(通过 XX:ReservedCodeCacheSize控制大小)中.机器码越长,越容易填满,满了之后回关闭即时编译(CodeCache is full. Compiler has been disabled).

[JDK源码中的内联规则](http://hg.openjdk.java.net/jdk/jdk/file/da387726a4f5/src/hotspot/share/opto/bytecodeInfo.cpp#l197)

首先: **`-XX:CompileCommand`中的`inline`指令指定的以及由`@ForceInline`注解(仅限JDK内部)的方法,会被强制内联.**而由 `-XX:CompileCommand` 中的 `dontinline` 指令或` exclude` 指令（表示不编译）指定的方法，以及由 `@DontInline` 注解的方法（仅限于 JDK 内部方法），则始终不会被内联。

其次:如果调用字节码对应的符号引用未被解析,目标方法所在类未被初始化,或者方法是本地方法,都将导致无法内联.

再次:C2 不支持内联超过 9 层的调用（可以通过虚拟机参数 -XX:MaxInlineLevel 调整），以及 1 层的直接递归调用（可以通过虚拟机参数 -XX:MaxRecursiveInlineLevel 调整）。

最后:即时编译器将根据方法调用指令所在的程序路径的热度，目标方法的调用次数及大小，以及当前 IR 图的大小来决定方法调用能否被内联。

![编译器中相关参数](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223145207533.png)



## 编译器去虚化

**即时编译器的去虚化分为完全去虚化以及条件去虚化(guarded devirtualization)**

**完全去虚化**:通过类型推导或者类层次分析(class hierarchy analysis).识别虚方法调用的唯一目标方法,从而将其转换为直接调用的一种优化手段.关键在于证明虚方法调用的目标方法是唯一的**.**

**条件去虚化**:将虚方法调用转换为若干个类型测试以及直接调用的一种优化手段.关键在于找到需要进行比较的类型.

基于上述代码分析

```
abstract class BinaryOp {
  public abstract int apply(int a, int b);
}
 
class Add extends BinaryOp {
  public int apply(int a, int b) {
    return a + b;
  }
}
 
class Sub extends BinaryOp {
  public int apply(int a, int b) {
    return a - b;
  }
}
```

### 基于类型推导的完全去虚化

类型推导的完全去虚化将通过数据流分析推导出调用者的动态类型，从而确定具体的目标方法。

```
public static int foo() {
  BinaryOp op = new Add();
  return op.apply(2, 1);
}
 
public static int bar(BinaryOp op) {
  op = (Add) op;
  return op.apply(2, 1);
}
```

**foo方法内联前**

![image-20211223163912871](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223163912871.png)

**bar方法内联前**

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223163956463.png" alt="image-20211223163956463" style="zoom:50%;" />



在上面两张 IR 图中，方法调用的调用者（即 8 号 CallTarget 节点的第一个依赖值）分别为 2 号 New 节点，以及 5 号 Pi 节点。后者可以简单看成强制转换后的精确类型。由于这两个节点的类型均被精确为 Add 类，因此，原 invokevirtual 指令对应的 9 号 invoke 节点都被识别对 Add.apply 方法的调用。

**bar 方法的 IR 图（方法内联及逃逸分析后)**

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223164046874.png" alt="image-20211223164046874" style="zoom:50%;" />

**foo 方法的 IR 图（方法内联后）**

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223164210361.png" alt="image-20211223164210361" style="zoom:50%;" />



### 基于类层次分析的完全去虚化

基于类层次分析的完全去虚化通过分析 Java 虚拟机中所有已被加载的类，判断某个抽象方法或者接口方法是否仅有一个实现。如果是，那么对这些方法的调用将只能调用至该具体实现中。
Java 虚拟机的做法是为当前编译结果注册若干个假设（assumption），假定某抽象类只有一个子类，或者某抽象方法只有一个具体实现，又或者某类没有子类等。
之后，每当新的类被加载，Java 虚拟机便会重新验证这些假设。如果某个假设不再成立，那么 Java 虚拟机便会对其所属的编译结果进行去优化。

通过将类修饰为final类,即时编译器便可以不用生成对应的假设.使得编译结果更加精简,并减少类加载时锁需验证的内容.

然而，对于接口方法调用，该去虚化手段则不能移除动态类型检测。这是因为在执行 invokeinterface 指令时，Java 虚拟机必须对调用者的动态类型进行测试，看它是否实现了目标接口方法所在的接口。

> Java 类验证器将接口类型直接看成 Object 类型，所以有可能出现声明类型为接口，实际类型没有继承该接口的情况，如下例所示。

既然这一类型测试无法避免，C2 干脆就不对接口方法调用进行基于类层次分析的完全去虚化，而是依赖于接下来的条件去虚化。



### 条件去虚化

条件去虚化通过向代码中添加若干个类型比较，将虚方法调用转换为若干个直接调用。

具体的原理非常简单，是将调用者的动态类型，依次与 Java 虚拟机所收集的类型 Profile 中记录的类型相比较。如果匹配，则直接调用该记录类型所对应的目标方法。

实例:

```
  //实际调用
  public static int test(BinaryOp op) {
    return op.apply(2, 1);
  }
  //条件去虚化后伪代码
  public static int test(BinaryOp op) {
    if (op.getClass() == Sub.class) {
      return 2 - 1; // inlined Sub.apply
    } else if (op.getClass() == Add.class) {
      return 2 + 1; // inlined Add.apply
    } else {
      ... // 当匹配不到类型 Profile 中的类型怎么办？
    }
  }
 
```

如果遍历完类型 Profile 中的所有记录，仍旧匹配不到调用者的动态类型，那么即时编译器有两种选择。

1. 如果类型 Profile 是完整的，也就是说，所有出现过的动态类型都被记录至类型 Profile 之中，那么即时编译器可以让程序进行去优化，重新收集类型 Profile，对应的 IR 图如下所示（这里 27 号 TypeSwitch 节点等价于前面伪代码中的多个 if 语句）：
 <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223165950287.png" alt="image-20211223165950287" style="zoom:50%;" />

2. 如果类型 Profile 是不完整的，也就是说，某些出现过的动态类型并没有记录至类型 Profile 之中，那么重新收集并没有多大作用。此时，即时编译器可以让程序进行原本的虚调用，通过内联缓存进行调用，或者通过方法表进行动态绑定。 

    **当匹配不到动态类型时进行去优化**

    对应的 IR 图如下所示
    
    ![image-20211223170134423](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211223170134423.png)

**当匹配不到动态类型时进行虚调用（仅在 Graal 中使用。）**

在 C2 中，如果类型 Profile 是不完整的，即时编译器压根不会进行条件去虚化，而是直接使用内联缓存或者方法表。