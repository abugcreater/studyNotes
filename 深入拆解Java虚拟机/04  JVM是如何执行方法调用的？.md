# 04 | JVM是如何执行方法调用的？

java编译器对重载方法的选取过程:

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；
2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

```
void invoke(Object obj, Object... args) { ... }
void invoke(String s, Object obj, Object... args) { ... }
当第一个传参为null时,两者都是匹配的,但是由于string是object的子类,则选择第二个方法
```



### JVM 的静态绑定和动态绑定

Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符，它是由方法的参数类型以及返回类型所构成。如果同一个类中存在名字相同且描述符也相同的方法时,jvm会在类验证阶段报错.

Java的重写通过编译器生成[桥接方法](https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html)实现.

确切地说，Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

具体来说，Java 字节码中与调用相关的指令共有五种。

>1. invokestatic：用于调用静态方法。
>2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
>3. invokevirtual：用于调用非私有实例方法。
>4. invokeinterface：用于调用接口方法。
>5. invokedynamic：用于调用动态方法。

```java
//指令的示例
interface 客户 {
  boolean isVIP();
}
 
class 商户 {
  public double 折后价格 (double 原价, 客户 某客户) {
    return 原价 * 0.8d;
  }
}
 
class 奸商 extends 商户 {
  @Override
  public double 折后价格 (double 原价, 客户 某客户) {
    if (某客户.isVIP()) {                         // invokeinterface      
      return 原价 * 价格歧视 ();                    // invokestatic
    } else {
      return super. 折后价格 (原价, 某客户);          // invokespecial
    }
  }
  public static double 价格歧视 () {
    // 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。
    return new Random()                          // invokespecial
           .nextDouble()                         // invokevirtual
           + 0.8d;
  }
}
```



### 调用指令的符号引用

Java 编译器会暂时用符号引用来表示该目标方法,符号引用包括方法所在的类名,方法名和方法描述符.根据目标方法是否为接口方法，这些引用可分为接口符号引用`InterfaceMethodref `和非接口符号引用`Methodref `。

Java虚拟机对非接口符号引用的查找步骤;

1. 在 C 中查找符合名字及描述符的方法。
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

Java虚拟机对接口符号引用的查找步骤;

1. 在 I 中查找符合名字及描述符的方法。
2. 如果没有找到，在 Object 类中的公有实例方法中搜索。
3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。



### 虚方法调用

`invokevirtual`与`invokeinterface`在Java虚拟机中属于虚方法的调用.如果虚方法是final修饰的,则使用了静态绑定.其他情况下使用动态绑定.Java为每个类生成一张方法表确定目标方法.

### 方法表

`invokevirtual` 使用的虚方法表(virtual method table,vtable)与`invokeinterface`使用的接口方法表(interface method table,itable),原理类似.

方法表结构上是个数组,每个数组元素指向当前类及祖先类中非私有的实例方法.

方法表满足:

1. 子类方法表中包含父类方法表中的所有方法
2. 子类方法在方法表中的索引值与他重写的父类方法索引值相同

执行时,Java虚拟机获取调用者的实际类型,查找其方法表,根据索引值获得方法.这个过程称为动态绑定.

JIT使用内联缓存(inlining cache)和方法内联(method inlining)对动态绑定过程进行优化.

### 内联缓存

内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。我们可以通过设置参数`java -XX:CompileCommand=dontinline`设置不使用内联缓存.

针对多态优化:

1. 单态（monomorphic）指的是仅有一种状态的情况。
2. 多态（polymorphic）指的是有限数量种状态的情况。二态（bimorphic）是多态的其中一种。
3. 超多态（megamorphic）指的是更多种状态的情况。通常我们用一个具体数值来区分多态和超多态。在这个数值之下，我们称之为多态。否则，我们称之为超多态。



单态内联缓存，便是只缓存了一种动态类型以及它所对应的目标方法,比较类型,如果命中直接调用.

多态内联缓存则缓存了多个动态类型及其目标方法。它需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法。

一般情况下,Java虚拟机只采用单态内联缓存.当没有命中时有两种策略:

1. 替换缓存中的记录.但是当轮流执行方法调用时会增加写负担
2. 直接使用去查方法表