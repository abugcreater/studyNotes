# 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？

![image-20211125172411568](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125172411568.png)

## 如何分析一个“排序算法”？

### 排序算法的执行效率

**1. 最好情况、最坏情况、平均情况时间复杂度**

**2. 时间复杂度的系数、常数 、低阶**

**3. 比较次数和交换（或移动）次数**

### 排序算法的内存消耗

算法的内存消耗可以通过空间复杂度来衡量.**原地排序**（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

### 排序算法的稳定性

**稳定性**这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。顺序不变的称为稳定算法,改变的称为不稳定算法.

## 冒泡排序（Bubble Sort）

![image-20211125172733001](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125172733001.png)

单次冒泡排序后的结果.

![image-20211125172757180](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125172757180.png)

最终冒泡排序后的结果

```java
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

**第一，冒泡排序是原地排序算法**

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

**第二，冒泡排序是稳定的排序算法**

为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

**第三，冒泡排序的时间复杂度是多少？**

最好情况时间复杂度是 O(n),最坏情况时间复杂度为 O(n2)

![image-20211125173031133](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125173031133.png)

**有序度**是数组中具有有序关系的元素对的个数

```
数学表达式:
有序元素对：a[i] <= a[j], 如果 i < j。
```

![image-20211125173130922](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125173130922.png)

对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是**n\*(n-1)/2**，也就是 15。我们把这种完全有序的数组的有序度叫作**满有序度**。

逆序度与有序度相反

```
逆序元素对：a[i] > a[j], 如果 i < j。
```

**逆序度 = 满有序度 - 有序度**。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了.

## 插入排序（Insertion Sort）

![image-20211125173349687](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125173349687.png)

这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。

首先，我们将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

![image-20211125173515956](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125173515956.png)

```
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;
 
  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

**第一，插入排序是原地排序算法**

**第二，插入排序是稳定的排序算法**

对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法

**第三，插入排序的时间复杂度是多少？**

最好情况时间复杂度是 O(n),最坏情况时间复杂度为 O(n2),平均时间复杂度O(n)

## 选择排序（Selection Sort）

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![image-20211125173719093](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125173719093.png)

首先，选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。你可以自己来分析看看。

选择排序是一种不稳定的排序算法。从我前面画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。

## 解答标题

我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个

```java
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}
 
插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

[希尔排序](https://zh.wikipedia.org/wiki/希尔排序) 插入排序的进阶,根据步长进行插入排序.

