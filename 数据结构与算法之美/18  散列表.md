# 18 | 散列表

### 散列思想

**散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。**

![image-20211228172149530](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211228172149530.png)

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

### 散列函数

散列函数,可以把它定义成**hash(key)**，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。

**散列函数设计的基本要求**：

1. 散列函数计算得到的散列值是一个非负整数；
2. 如果 key1 = key2，那 hash(key1) == hash(key2)；
3. 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。 (遇到哈希冲突时不满足)

### 散列冲突

散列冲突解决方案:开放寻址法（open addressing）和链表法（chaining）

#### 1. 开放寻址法

较简单的探测方法，**线性探测**（Linear Probing).当遇到哈希冲突时向后面节点查找,知道找到位置.

支持增,查,删.删时不能直接删除元素,因为查找时遇到空闲位置会认为找不到,可以设置元素属性为删除状态.

![image-20211228172744291](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211228172744291.png)

除了线性探测方法之外，还有另外两种比较经典的探测方法，**二次探测**（Quadratic probing）和**双重散列**（Double hashing）

二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22

双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置

无论哪种方法在遇到空闲位置不多时冲突都会大大提高,我们用**装载因子**（load factor）来表示空位的多少。

```
散列表的装载因子 = 填入表中的元素个数 / 散列表的长度
装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。
```

#### 2. 链表法

在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

![image-20211228173109090](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211228173109090.png)

### Word 文档中单词拼写检查功能是如何实现的？

将所有常用单子都存在散列表中,将该散列表保存到内存中,拿用户输入的单词去散列表中查找。

1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

   遍历10万条URL记录，URL为key，声明一个记录访问次数的字段count，存入散列表，每次遇到重复的就累加count，最后对count进行桶排序或者快速排序。

2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

   分别将2个数组的字符串通过散列函数映射到散列表，散列表中的元素值为次数。注意，先存储的数组中的相同元素值不进行次数累加。最后，统计散列表中元素值大于等于2的散列值对应的字符串就是两个数组中相同的字符串



## 工业级散列表设计

### 如何设计散列函数？

散列函数的设计不能太复杂,避免计算消耗性能.并且散列函数生成的值要尽可能随机并且均匀分布.

常用函数有:数据分析法、直接寻址法、平方取中法、折叠法、随机数法等

### 装载因子过大了怎么办？

针对散列表,当装载因子过大时,可以使用动态扩容解决,申请更大的散列表,将数据迁移到新散列表中.

插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。可以在装载因子小于某个值之后，启动动态缩容

### 如何避免低效地扩容？

当数据量非常大时,单次迁移所有数据会非常慢,此时单次迁移所有数据就不合适.

我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。有新的插入时将数据插入新表中,然后搬运部分老数据到新表中.

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220111110743425.png" alt="image-20220111110743425" style="zoom:43%;" />

对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。

### 如何选择冲突解决方法？

#### 1. 开放寻址法

优点:数据存储在数组中,有效利用CPU加速.且序列化简单.

缺点:删除数据麻烦,需要特殊标记,冲突代价高,装载因子上限小,浪费空间

适用场景:**当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因**

#### 2. 链表法

优点:内存利用率高,对大装载因子容忍度高支持更多优化策略

缺点:使用指针不利于CPU加速,序列化困难

适用场景:**基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表**

### 工业级散列表举例分析

已Java中的HashMap为例

#### 1. 初始大小

初始大小是 16,可通过初始值,减少扩容次数

#### 2. 装载因子和动态扩容

默认是 0.75，元素个数超过 0.75*capacity时扩容为原来两倍

#### 3. 散列冲突解决方法

采用链表法来解决冲突,链表过长时转为红黑树,少于8(默认值)时转为链表

#### 4. 散列函数

追求的是简单高效、分布均匀

```
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capitity -1); //capicity 表示散列表的大小
}
```

### 如何打造一个工业级水平的散列表

- 设计一个合适的散列函数；支持快速的删改查
- 定义装载因子阈值，并且设计动态扩容策略； 内存占用合理,不浪费空间
- 选择合适的散列冲突解决方法。性呢个稳定

## 为什么散列表和链表经常会一起使用？

### LRU 缓存淘汰算法

我们需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除.

使用散列表和链表组合使用降低时间复杂度.

![image-20220119145655634](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220119145655634.png)

每个节点在两条链上,一条是散列表的开链,一条是双向链表.**data存储数据,前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中**

查找:通过散列表和开链查询;

删除:将节点三处只需要修改前驱节点和修改后驱节点.

添加:先要判断是否在缓存里,在的话移到尾部;不在需要将数据添加到尾部,如果满了要先删除头节点.

### Redis 有序集合

实际上，在有序集合中，每个成员对象有两个重要的属性，**key**（键值）和**score**（分值）

按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 LRU 缓存淘汰算法的解决方法类似.按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。

### Java LinkedHashMap

LinkedHashMap 也是通过散列表和链表组合在一起实现的.

每次调用 put() /get()函数，往 LinkedHashMap 中添加数据的时候，都会将数据添加到链表的尾部

**LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突**。

### 解答开篇 & 内容小结

为了能使散列后的数据有序访问,所以散列表与链表会经常一起使用.







