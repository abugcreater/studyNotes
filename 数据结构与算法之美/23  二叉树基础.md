# 23 | 二叉树基础

## 什么样的二叉树适合用数组来存储

### 树（Tree）

可以[递归](https://en.wikipedia.org/wiki/Recursion)地定义为节点的集合，其中每个节点是一个数据结构，由一个值和对节点的引用列表组成。树的起点是“根节点”，参考节点是“子节点”。没有引用重复，也没有指向根

相关概念:**高度**（Height）、**深度**（Depth）、**层**（Level）

- 高度:节点到叶子节点的最长路径
- 深度:根节点到这个节点锁经历的边的个数
- 层数:深度+1
- 树的高度:根节点的高度

### 二叉树（Binary Tree）

二叉树:每个节点最多有两个节点的树.

叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作**满二叉树**

叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作**完全二叉树**

对于平常的二叉树存储一般使用简单、直观的**链式存储法**.

![image-20220120103533693](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220120103533693.png)

对于完全二叉树可以使用**顺序存储法**;我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置以此类推.

![image-20220120103630338](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220120103630338.png)

### 二叉树的遍历

经典的方法有三种，**前序遍历**、**中序遍历**和**后序遍历**

- 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
- 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
- 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。



引申:[Tree (data structure)]https://en.wikipedia.org/wiki/Tree_(data_structure)#Representations

## 有了如此高效的散列表，为什么还需要二叉树？

### 二叉查找树（Binary Search Tree）

**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。**

#### 1. 二叉查找树的查找操作

我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

#### 2. 二叉查找树的插入操作

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。

#### 3. 二叉查找树的删除操作

第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。

第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。

第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。

![image-20220120154852202](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220120154852202.png)

#### 二叉查找树的其他操作

**中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效**。因此，二叉查找树也叫作二叉排序树。

### 支持重复数据的二叉查找树

那如果存储的两个对象键值相同，这种情况该怎么处理呢？

1. 二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。
2. 把这个新插入的数据当作大于这个节点的值来处理。

### 二叉查找树的时间复杂度分析

最糟糕的情况下二叉树退化成链表,查找的时间复杂度变为O(n)

最理想的情况**时间复杂度跟树的高度成正比，也就是 O(height)** 完全二叉树的层数小于等于 log2n +1,所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn).