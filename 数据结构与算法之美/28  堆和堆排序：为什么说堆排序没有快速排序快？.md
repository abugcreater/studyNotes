# 28 | 堆和堆排序：为什么说堆排序没有快速排序快？

## 如何理解“堆”？

- 堆是一个完全二叉树；
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

大根堆:根节点值最大;小根堆:根节点值最小

## 如何实现一个堆？

完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

![image-20220215230732801](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220215230732801.png)

左节点 i*2;有节点 i*2 + 1,父节点 i/2

### 1. 往堆中插入一个元素

**堆化**（heapify）:调整，让其重新满足堆的特性

**从下往上**:顺着节点所在的路径，向上或者向下，对比，然后交换.与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点.

![image-20220215231112494](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220215231112494.png)

```
public class Heap {
  private int[] a; // 数组，从下标 1 开始存储数据
  private int n;  // 堆可以存储的最大数据个数
  private int count; // 堆中已经存储的数据个数
 
  public Heap(int capacity) {
    a = new int[capacity + 1];
    n = capacity;
    count = 0;
  }
 
  public void insert(int data) {
    if (count >= n) return; // 堆满了
    ++count;
    a[count] = data;
    int i = count;
    while (i/2 > 0 && a[i] > a[i/2]) { // 自下往上堆化
      swap(a, i, i/2); // swap() 函数作用：交换下标为 i 和 i/2 的两个元素
      i = i/2;
    }
  }
 }
```

### 2. 删除堆顶元素

把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是**从上往下的堆化方法**。

![image-20220215231314260](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220215231314260.png)

```
public void removeMax() {
  if (count == 0) return -1; // 堆中没有数据
  a[1] = a[count];
  --count;
  heapify(a, count, 1);
}
 
private void heapify(int[] a, int n, int i) { // 自上往下堆化
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```

## 如何基于堆实现排序？

### 1. 建堆

有两种思路:

1.从无到有插入数据

2.从后往前处理数组，并且每个数据都是从上往下堆化



第二种思路过程

![image-20220215233113737](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220215233113737.png)

```
private static void buildHeap(int[] a, int n) {
  for (int i = n/2; i >= 1; --i) {
    heapify(a, n, i);
  }
}
 
private static void heapify(int[] a, int n, int i) {
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```

### 2. 排序

当堆顶元素移除之后，我们把下标为 nn 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1n−1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n−1n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 11 的一个元素，排序工作就完成了

![image-20220215233422080](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220215233422080.png)

```
// n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置。
public static void sort(int[] a, int n) {
  buildHeap(a, n);
  int k = n;
  while (k > 1) {
    swap(a, 1, k);
    --k;
    heapify(a, k, 1);
  }
}
```

所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)O(n)，排序过程的时间复杂度是 O(nlogn)O(nlog⁡n)，所以，堆排序整体的时间复杂度是 O(nlogn)O(nlog⁡n)。



**第一点，堆排序数据访问的方式没有快速排序友好。**

**第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。**