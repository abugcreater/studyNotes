# 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？

## 为什么需要复杂度分析？

我们现有的通过统计,监控,得到算法执行的时间和占用的内存大小,叫做**事后统计法**.该方法存在以下两个问题

**1. 测试结果非常依赖测试环境**
**2. 测试结果受数据规模的影响很大** 

## 大 O 复杂度表示法

**一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法**

```
int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

假设每段代码的执行时间相同为一个时钟unit_time,则一共执行的时间是 `(1 + 1 + n + n)*unit_time`.可以得到规律**所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。 

我们把这个规律总结一个公式

![image-20211018173457654](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018173457654.png)

大O时间复杂度实际上并不具体表示代码真正执行的时间,而是表示**代码执行时间随数据规模增长的变化趋势**,也叫**渐进时间复杂度**（asymptotic time complexity）



## 时间复杂度分析

**1. 只关注循环执行次数最多的一段代码**

我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了

**2. 加法法则：总复杂度等于量级最大的那段代码的复杂度**

总的时间复杂度就等于量级最大的那段代码的时间复杂度

换算成公式:

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

**3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

换算成公式:

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).



## 常见时间复杂度实例分析

![image-20211018174434706](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211018174434706.png)

按照复杂度量级分,可以分为**多项式量级**和**非多项式量级**。非多项式量级只有两个：O(2n) 和 O(n!)。

**1. O(1)**

只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)**。



**2. O(logn)、O(nlogn)**

```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

以上述代码举例.因为第三行被执行的最多,我们只需要统计这行代码被执行了多少次就行了.

log₂n = x 推导出时间复杂度为  O(log n)  log的底数可以为任何数.

**在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))**

如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

**3. O(m+n)、O(m\*n)**

代码的复杂度**由两个数据的规模**来决定.

```
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }
 
  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }
  return sum_1 + sum_2;
}
```



## 空间复杂度分析

空间复杂度全称就是**渐进空间复杂度**（asymptotic space complexity），**表示算法的存储空间与数据规模之间的增长关系**。

```
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }
 
  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

用上述代码举例,第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。