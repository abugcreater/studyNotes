# 12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？

## 归并排序的原理

归并排序(Merge Sort):利用了分治思想如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

![image-20211130143814988](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211130143814988.png)

分治算法一般都是用递归来实现的。**分治是一种解决问题的处理思想，递归是一种编程技巧**.

```java
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
 
终止条件：
p >= r 不用再继续分解

伪代码
// 归并排序算法, A 是数组，n 表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}
 
// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return
 
  // 取 p 到 r 之间的中间位置 q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}

```

![image-20211130144051764](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211130144051764.png)

merge算法实现思路

## 归并排序的性能分析

**第一，归并排序是稳定的排序算法**

在最后执行merge方法时,数值相同的元素并没有做位置改变,所以他是稳定的排序算法

**第二，归并排序的时间复杂度是多少？**

```
T(a) = T(b) + T(c) + K 
该公式表示将a问题分解成子问题b和子问题c 所消耗的时间加上 将问题和起来消耗的时间K
```

从刚刚的分析，我们可以得到一个重要的结论：**不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。**

在归并中如果对n个元素排序的时间为T(n),则将n个元素分解成2个数组的时间复杂度为2*T(n/2),merge的时间复杂度为O(n),则推导如下

```
T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。
T(n) = 2*T(n/2) + n； n>1

T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
     ......
     = 2^k * T(n/2^k) + k * n     
     
当 T(1) 时 T(1) = T(n/2^k)=>1 = n/2^k
得到O(n) = O(nlogn)
```

**第三，归并排序的空间复杂度**

归并排序不是原地排序算法.归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。

实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。

## 快速排序的原理

快速排序算法（Quicksort）利用的也是分治思想。

快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。

我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。当最后区间为1时则所有元素都有序了.

![image-20211130145533865](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211130145533865.png)

根据上诉思想推到得到的递推公式为

```java
quick_sort(a,c) = quick_sort(a,b-1) + quick(b+1,c)
终止条件
a>=c

根据递推公式得到的伪代码
// 快速排序，A 是数组，n 表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r 为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}

partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i
```

`partition`方法的思想类似于插入排序,我们通过游标 i 把 A[p…r-1] 分成两部分。A[p…i-1] 的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i…r-1] 是“未处理区间”。我们每次都从未处理的区间 A[i…r-1] 中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i] 的位置。

![image-20211130150139832](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211130150139832.png)

快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？

归并排序的处理过程是**由下到上**的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是**由上到下**的，先分区，然后再处理子问题。

## 快速排序的性能分析

快排是一种原地、不稳定的排序算法。

对于递归代码的时间复杂度，我前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)。极端情况下比如数组本身就是有序的则快排的时间复杂度会退化成O(n2).

## 解答开篇

利用快速排序,我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。

如果 p+1=K，那 A[p] 就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K<p+1，那我们就在 A[0…p-1] 区间查找。