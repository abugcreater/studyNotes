# 06 | 链表（上）：如何实现LRU缓存淘汰算法?

## 五花八门的链表结构

链表不需要一块连续的内存空间，它通过“指针”将一组**零散的内存块**串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。

![image-20211020165915902](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211020165915902.png)

当前最常见的三种列表结构:

1. 单向链表

   为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址.我们把这个记录下个结点地址的指针叫作**后继指针 next**。

![image-20211020170056109](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211020170056109.png)

2. 循环链表

   跟单链表唯一的区别就在尾结点,循环链表的尾结点指针是指向链表的头结点。

   ![image-20211020170157364](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211020170157364.png)



3. 双向链表

   结合了单向链表与循环链表,平常开发时通常使用双向链表.

![image-20211020170230372](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211020170230372.png)

## 链表 VS 数组性能大比拼

![image-20211020170338541](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211020170338541.png)

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。

链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。



## LRU算法思想

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：

- 如果此时缓存未满，则将此结点直接插入到链表的头部；
- 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。